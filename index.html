<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2D Shooter – Fixed World Bounds</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; touch-action:none; background:#000; }
    canvas { display:block; background:#222; margin:auto; }
    /* Overlays */
    #startOverlay, #endOverlay {
      position:absolute; top:0; left:0; right:0; bottom:0;
      background:rgba(0,0,0,0.9); color:white;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      font-family:sans-serif; z-index:100;
    }
    #endOverlay { display:none; }
    #startOverlay h1 { font-size:3em; margin-bottom:0.5em; }
    #startOverlay label { font-size:1.2em; margin:0.5em 0; }
    #startOverlay input[type="text"] { font-size:1.2em; padding:0.5em; width:250px; }
    #startOverlay button { font-size:1.3em; padding:0.6em 1em; margin:0.5em; }
    #sliderContainer { margin-top:1em; text-align:center; }
    #sliderContainer input[type="range"] { width:300px; }
    /* HUD */
    #ui { position:absolute; top:10px; left:10px; color:white; z-index:5; font-family:sans-serif; }
    #ui div { margin-bottom:4px; }
    /* Inventory */
    #inventory { position:absolute; top:10px; right:10px; width:50px; height:50px;
      background:rgba(0,0,0,0.5); color:white; font-size:1.5em;
      display:flex; align-items:center; justify-content:center;
      border:2px solid #fff; border-radius:4px; cursor:pointer; z-index:5; }
    #inventoryDetails {
      position:absolute; top:70px; right:10px;
      background:rgba(0,0,0,0.8); color:white; padding:10px;
      border:2px solid #fff; border-radius:4px; display:none; z-index:5;
      font-family:sans-serif;
    }
    /* Joystick zones */
    .joystick-zone { position:absolute; z-index:5; bottom:20px; }
    #leftZone { left:20px; } #rightZone{ right:20px; }
    /* Item Shop Styling */
    #shopItemsContainer .shop-item {
      background: #333;
      border: 1px solid #555;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1.2em;
      text-align: center; /* Center text in items */
    }
    #shopItemsContainer .shop-item:hover {
      background: #444;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <!-- Held Power Display -->
  <div id="heldPowerDisplay" style="position:absolute; top:10px; left: 50%; transform: translateX(-50%); width:50px; height:50px; background:rgba(0,0,0,0.5); color:white; font-size:2em; display:none; align-items:center; justify-content:center; border:2px solid #fff; border-radius:4px; cursor:pointer; z-index:10;">
    <!-- Emoji will be placed here by JavaScript -->
  </div>

  <!-- Item Shop Overlay -->
  <div id="itemShopOverlay" style="position:absolute; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); color:white; display:none; flex-direction:column; align-items:center; justify-content:center; font-family:sans-serif; z-index:150;">
    <h2>Item Shop</h2>
    <div id="shopItemsContainer" style="display:flex; flex-wrap:wrap; justify-content:center; max-width: 80%;">
      <!-- Items will be added here by JavaScript -->
    </div>
    <p style="margin-top: 20px;">Click 'Shop' button again to close</p>
    <p>Kill Coins: <span id="shopKillCoinsDisplay">0</span></p>
  </div>

  <!-- Start / End Overlays -->
  <div id="startOverlay">
    <h1>2D Shooter</h1>
    <label>Your ID: <input id="myId" type="text" placeholder="peer‑id"></label>
    <button id="initPeer">Init</button>
    <label>Connect to: <input id="otherId" type="text" placeholder="peer‑id"></label>
    <button id="connectPeer">Connect</button>
    <button id="startGame">Start</button>
    <div id="connStatus" style="margin-top:0.5em; font-size:1em;"></div>
    <div id="sliderContainer">
      <label for="jSize">Joystick Size: <span id="jSizeVal">150</span>px</label><br>
      <input id="jSize" type="range" min="100" max="300" value="150">
    </div>
  </div>

  <div id="endOverlay">
    <h1 id="endMsg"></h1>
    <button id="rematch">Rematch</button>
    <button id="respawnButton" style="display: none;">Respawn</button>
  </div>

  <!-- HUD -->
  <div id="ui">
    <div>You: <progress id="myHealth" max="5" value="5"></progress></div>
    <!-- Opponent health bars will be added here dynamically -->
    <div>
      <button id="toggleShopButton" style="font-size: 0.8em; padding: 3px 6px; margin-top: 5px;">Shop</button>
      <button id="detonateStickyButton" style="font-size: 0.8em; padding: 3px 6px; margin-top: 5px; display: none; margin-left: 5px;">Detonate</button>
    </div>
  </div>

  <!-- Inventory -->
  <div id="inventory">I</div>
  <div id="inventoryDetails">
    <strong>Inventory</strong><br>
    Bullets: ∞<br>
    Blocks: interactive<br>
    Kills: <span id="myKills">0</span>
  </div>

  <!-- Joysticks -->
  <div id="leftZone" class="joystick-zone"></div>
  <div id="rightZone" class="joystick-zone"></div>

  <script>
  // — Virtual World Constants —
  const WORLD_WIDTH  = 2400;
  const WORLD_HEIGHT = 2400;
  const CAMERA_ZOOM_OUT_FACTOR = 1.1; // Was 0.75, larger value means more zoomed IN

  // — Canvas & Matter Setup —
  const canvas = document.getElementById('game');
  const ctx    = canvas.getContext('2d');
  let cw=window.innerWidth, ch=window.innerHeight;
  canvas.width = cw; canvas.height = ch;

  const { Engine, World, Bodies, Body, Events, Vector } = Matter;
  const engine = Engine.create(), world = engine.world;
  world.gravity.y = 0; // Original Matter.js gravity setting

  // — Compute uniform scale & letterbox offsets —
  let scale=1, xOffset=0, yOffset=0;
  function updateViewport(){
    cw=window.innerWidth; ch=window.innerHeight;
    // Which dimension constrains the world?
    scale = Math.min(cw/WORLD_WIDTH, ch/WORLD_HEIGHT) * CAMERA_ZOOM_OUT_FACTOR;
    // compute letterboxing centering
    xOffset = (cw - WORLD_WIDTH * scale) / 2;
    yOffset = (ch - WORLD_HEIGHT * scale) / 2;
    canvas.width = cw; canvas.height = ch;
  }
  window.addEventListener('resize', updateViewport);
  updateViewport();

  // — Camera (follows player) —
  let cam = { x: WORLD_WIDTH/2, y: WORLD_HEIGHT/2, shake:0 };
  function applyCamera(){
    ctx.setTransform(1,0,0,1,0,0);
    // clear letterbox
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,cw,ch);
    // apply letterbox + scale
    ctx.translate(xOffset, yOffset);
    ctx.scale(scale, scale);
    // apply camera shake & centering
    const sx = (Math.random()-0.5)*cam.shake;
    const sy = (Math.random()-0.5)*cam.shake;
    ctx.translate(-cam.x + WORLD_WIDTH/2 + sx, -cam.y + WORLD_HEIGHT/2 + sy);
    cam.shake = Math.max(0, cam.shake * 0.9);
  }

  // — World Borders (fixed coords) —
  const borders = [
      Bodies.rectangle(WORLD_WIDTH/2, -10, WORLD_WIDTH, 20, { isStatic:true }),
      Bodies.rectangle(WORLD_WIDTH/2, WORLD_HEIGHT+10, WORLD_WIDTH, 20, { isStatic:true }),
      Bodies.rectangle(-10, WORLD_HEIGHT/2, 20, WORLD_HEIGHT, { isStatic:true }),
      Bodies.rectangle(WORLD_WIDTH+10, WORLD_HEIGHT/2, 20, WORLD_HEIGHT, { isStatic:true })
  ];
  World.add(world, borders);

  // — Map Data Parsing —
  function parseMapData(mapString) {
    const blocksData = [];
    if (!mapString || typeof mapString !== 'string') {
      return blocksData; // Return empty if input is invalid
    }
    const blockTokens = mapString.split('-');
    for (const token of blockTokens) {
      let isInteractive = false;
      let coordString = token;
      if (token.startsWith('i')) {
        isInteractive = true;
        coordString = token.substring(1);
      }
      const parts = coordString.split(',');
      if (parts.length === 2) {
        const x = parseInt(parts[0], 10);
        const y = parseInt(parts[1], 10);
        if (!isNaN(x) && !isNaN(y)) {
          blocksData.push({ x, y, isInteractive });
        }
      }
    }
    return blocksData;
  }

  // — Player & Other Entities —
  const size = 40; // Player size
  const spawnPoints = [
    { x: 100, y: WORLD_HEIGHT / 2 },
    { x: WORLD_WIDTH - 100, y: WORLD_HEIGHT / 2 },
    { x: WORLD_WIDTH / 2, y: 100 },
    { x: WORLD_WIDTH / 2, y: WORLD_HEIGHT - 100 },
    { x: 200, y: 200 },
    { x: WORLD_WIDTH - 200, y: WORLD_HEIGHT - 200 }
  ];
  let localPlayerSpawnIndex = 0; // Local player always takes the first spawn point

  const player = Bodies.rectangle(
      spawnPoints[localPlayerSpawnIndex].x,
      spawnPoints[localPlayerSpawnIndex].y,
      size, size, { restitution:0.2, frictionAir:0.1 } // Original properties
  );
  World.add(world, player);

  // Initial camera position update was missing in the previous attempt; it's part of applyCamera or cam object init.
  // Let's ensure cam is initialized correctly. The cam object is already global.
  // We'll set its initial x,y after player is created.
  cam.x = player.position.x;
  cam.y = player.position.y;

  let localPlayerState = 'alive'; // Player state: 'alive', 'dead'
  let opponents = {}; // Stores opponent data, keyed by peerId
  let peer; // Local PeerJS instance
  let nextOpponentSpawnIndex = 1; // Index for the next opponent's spawn point (starts from 1 as player takes 0)


  // — Blocks (from map string) —
  const blocks = []; // Array to hold all blocks for rendering and networking
  const mapString = "5,5-10,10-i15,15-20,20-i25,25-5,15-15,5"; // Example: grid coords
  const gridCellSize = 50; // Each grid cell is 50x50 pixels
  const blockSize = 50; // Visual size of the block

  const parsedBlocks = parseMapData(mapString);

  parsedBlocks.forEach((blockData, index) => {
    const pixelX = blockData.x * gridCellSize + blockSize / 2; // Center block in grid cell
    const pixelY = blockData.y * gridCellSize + blockSize / 2; // Center block in grid cell
    let blockBody;

    if (blockData.isInteractive) {
      blockBody = Bodies.rectangle(pixelX, pixelY, blockSize, blockSize, {
        restitution: 0.8,
        frictionAir: 0.02,
        density: 0.002, // Example Matter.js property
        _isInteractive: true, 
        render: { fillStyle: '#888' } 
      });
    } else {
      blockBody = Bodies.rectangle(pixelX, pixelY, blockSize, blockSize, {
        isStatic: true,
        _isInteractive: false, 
        render: { fillStyle: '#555' }
      });
    }

    blockBody._id = "map_block_" + index; // Unique ID
    blocks.push(blockBody);
  });

  World.add(world, blocks); // Add all new blocks to the world

  // — Bullets & IDs & Lifespan —
  const bullets = [];
  let bulletCounter = 0;
  function removeBullet(id){
    const idx = bullets.findIndex(b=>b._id===id);
    if(idx>=0){
      World.remove(world, bullets[idx]); // Reverted
      bullets.splice(idx,1);
    }
  }

  function initiateStickyBombDetonation(bomb, isAuthoritative) {
    if (!bomb || bomb._isExploding) return; // Already handled or no bomb

    bomb._isExploding = true; // Mark that this bomb is now exploding
    console.log(`${isAuthoritative ? "Authoritative" : "Non-authoritative"} detonation for sticky bomb: ${bomb._id}`);

    const explosionId = bomb._id + "_explosion_" + Date.now();
    const explosionEffect = {
      id: explosionId,
      x: bomb.position.x,
      y: bomb.position.y,
      radius: 0,
      maxRadius: GRENADE_EXPLOSION_RADIUS, // Using grenade constants for now
      speed: GRENADE_EXPLOSION_RADIUS / (EXPLOSION_DURATION / (1000 / 60)),
      color: EXPLOSION_COLOR,
      startTime: Date.now(),
      duration: EXPLOSION_DURATION,
      ownerId: bomb._ownerId
    };
    activeExplosions.push(explosionEffect);

    playBeep(100, 0.3);
    playBeep(50, 0.2, 0.1);
    navigator.vibrate?.([100, 50, 100]);

    if (isAuthoritative) {
      const explosionCenter = { x: explosionEffect.x, y: explosionEffect.y };

      // Damage & Force Opponents
      Object.entries(opponents).forEach(([opponentId, opData]) => {
        if (opData.body && opData.state === 'alive') {
          const dist = Math.hypot(opData.body.position.x - explosionCenter.x, opData.body.position.y - explosionCenter.y);
          if (dist < GRENADE_EXPLOSION_RADIUS) { // Using grenade radius
            send({
              damageEvent: {
                victimId: opponentId,
                instigatorId: bomb._ownerId,
                damageAmount: GRENADE_EXPLOSION_DAMAGE, // Using grenade damage
                type: 'sticky_bomb_explosion' 
              }
            });
            const angle = Math.atan2(opData.body.position.y - explosionCenter.y, opData.body.position.x - explosionCenter.x);
            const force = { x: Math.cos(angle) * GRENADE_EXPLOSION_FORCE_PLAYER, y: Math.sin(angle) * GRENADE_EXPLOSION_FORCE_PLAYER };
            Body.applyForce(opData.body, explosionCenter, force);
          }
        }
      });

      // Damage & Force Self (Local Player)
      if (player && localPlayerState === 'alive') {
        const distToSelf = Math.hypot(player.position.x - explosionCenter.x, player.position.y - explosionCenter.y);
        if (distToSelf < GRENADE_EXPLOSION_RADIUS) {
          damagePlayer(bomb._ownerId, GRENADE_EXPLOSION_DAMAGE);
          const angle = Math.atan2(player.position.y - explosionCenter.y, player.position.x - explosionCenter.x);
          const force = { x: Math.cos(angle) * GRENADE_EXPLOSION_FORCE_PLAYER, y: Math.sin(angle) * GRENADE_EXPLOSION_FORCE_PLAYER };
          Body.applyForce(player, explosionCenter, force);
        }
      }

      // Force on Interactive Blocks
      blocks.forEach(block => {
        if (block._isInteractive && block.body) {
          const dist = Math.hypot(block.position.x - explosionCenter.x, block.position.y - explosionCenter.y);
          if (dist < GRENADE_EXPLOSION_RADIUS) {
            const angle = Math.atan2(block.position.y - explosionCenter.y, block.position.x - explosionCenter.x);
            const force = { x: Math.cos(angle) * GRENADE_EXPLOSION_FORCE_BLOCK, y: Math.sin(angle) * GRENADE_EXPLOSION_FORCE_BLOCK };
            Body.applyForce(block, explosionCenter, force);
          }
        }
      });

      send({ stickyBombExploded: { bombId: bomb._id, explosion: explosionEffect } });
    }

    // Remove the sticky bomb body from the world and active list
    World.remove(world, bomb);
    const index = activeStickyBombs.findIndex(b => b._id === bomb._id);
    if (index > -1) {
      activeStickyBombs.splice(index, 1);
    }
    
    // Update button visibility if this was a locally owned bomb
    if (bomb._ownerId === (peer ? peer.id : 'local')) {
        updateDetonateButtonVisibility();
    }
  }

  function shoot(isLocal){
    const angle = Math.atan2(lastRight.y, lastRight.x);
    // const bid   = bulletCounter++; // Original
    const bid = (peer && peer.id ? peer.id + "_" : "local_") + bulletCounter++; // Keep unique ID for now
    const bx = player.position.x + Math.cos(angle)*(size/2+5);
    const by = player.position.y + Math.sin(angle)*(size/2+5);
    const bullet = Bodies.circle(bx, by, 5, { restitution:0.8, frictionAir:0.02, density:0.001 }); // Matter.js
    bullet._id = bid;
    bullet.shooterId = peer ? peer.id : "local"; // Keep shooterId logic
    Body.setVelocity(bullet, { x:Math.cos(angle)*15, y:Math.sin(angle)*15 }); // Matter.js
    bullets.push(bullet);
    World.add(world, bullet); // Matter.js
    // schedule auto‑dispersion
    setTimeout(()=>removeBullet(bullet._id), 3500);
    // network - ensure vx, vy are from Matter.js body.velocity
    if(isLocal && peer) send({ shoot:true, bullet:{ id:bullet._id, x:bx, y:by, vx:bullet.velocity.x, vy:bullet.velocity.y, shooterId: bullet.shooterId }});
    // feedback
    playBeep(600,0.05);
    navigator.vibrate?.(20);
  }

  function spawnRemoteBullet(bd, shooterId){ // shooterId is the sender of the shoot message
    if(bullets.some(b=>b._id===bd.id)) return;
    const bullet = Bodies.circle(bd.x, bd.y, 5, { restitution:0.8, frictionAir:0.02, density:0.001 }); // Matter.js
    bullet._id = bd.id;
    bullet.shooterId = shooterId; // Assign from passed shooterId
    Body.setVelocity(bullet, { x:bd.vx, y:bd.vy }); // Matter.js
    bullets.push(bullet);
    World.add(world, bullet); // Matter.js
    setTimeout(()=>removeBullet(bd.id), 3500);
  }

  // — Joysticks & Touch —
  let leftStick={x:0,y:0}, lastRight={x:0,y:0};
  let joystickSize=150, leftMgr, rightMgr;
  function createJoysticks(sz){
    if(leftMgr) leftMgr.destroy();
    if(rightMgr)rightMgr.destroy();
    ['leftZone','rightZone'].forEach(id=>{
      const el=document.getElementById(id);
      el.style.width=sz+'px'; el.style.height=sz+'px';
    });
    leftMgr  = nipplejs.create({ zone:document.getElementById('leftZone'), mode:'static', position:{ left:'50%', top:'50%' }, size:sz });
    rightMgr = nipplejs.create({ zone:document.getElementById('rightZone'),mode:'static', position:{ left:'50%', top:'50%' }, size:sz });
    leftMgr.on('move',(_,d)=>{ leftStick.x=d.vector.x; leftStick.y=-d.vector.y; })
           .on('end',()=>{ leftStick.x=0; leftStick.y=0; });
    rightMgr.on('move',(_,d)=>{ lastRight.x=d.vector.x; lastRight.y=-d.vector.y; })
            .on('end',()=>{ if(Math.hypot(lastRight.x,lastRight.y)>0.2) shoot(true); lastRight.x=0; lastRight.y=0; });
  }
  document.getElementById('jSize').addEventListener('input',e=>{
    joystickSize=+e.target.value;
    document.getElementById('jSizeVal').textContent=joystickSize;
    createJoysticks(joystickSize);
  });
  createJoysticks(joystickSize);

  canvas.addEventListener('touchstart',ev=>{
    const t=ev.touches[0];
    if(t.clientY > ch*0.6){
      const dx=t.clientX - (player.position.x*scale + xOffset);
      const dy=t.clientY - (player.position.y*scale + yOffset);
      lastRight.x = dx/Math.hypot(dx,dy);
      lastRight.y = dy/Math.hypot(dx,dy);
      shoot(true);
    }
  });

  // — Invisibility Activation —
  function activateInvisibility() {
    if (isInvisible || !player || localPlayerState !== 'alive') return; // Already invisible, player dead, or no player

    isInvisible = true;
    const invisibilityDuration = 5000; // 5 seconds
    invisibilityEndTime = Date.now() + invisibilityDuration;

    // Optional: Play a sound effect
    playBeep(800, 0.1); // Higher pitch beep for invisibility
    playBeep(1200, 0.1, 0.05); // Second beep shortly after

    if (peer) {
      send({ 
        playerPowerUpdate: { 
          targetId: peer.id, 
          power: 'invisibility', 
          active: true, 
          duration: invisibilityDuration 
        } 
      });
    }
    console.log("Invisibility activated. Ends at:", new Date(invisibilityEndTime).toLocaleTimeString());
  }

  function throwGrenade() {
    if (!player || localPlayerState !== 'alive') return;
    if (lastRight.x === 0 && lastRight.y === 0) {
        console.log("Cannot throw grenade without aiming direction.");
        // Optionally, provide feedback to the player here (e.g., a sound or UI message)
        // For now, just prevent throw and let the power be consumed in the click handler.
        // Or, better, the click handler should check this BEFORE consuming the power.
        // For this iteration, we assume the click handler ensures currentHeldPower is consumed.
        return; 
    }

    const angle = Math.atan2(lastRight.y, lastRight.x); // Use last aim direction
    const grenadeId = (peer ? peer.id : 'local') + "_grenade_" + Date.now();
    
    // Position slightly in front of player
    const startX = player.position.x + Math.cos(angle) * (size / 2 + GRENADE_SIZE);
    const startY = player.position.y + Math.sin(angle) * (size / 2 + GRENADE_SIZE);

    const grenadeBody = Bodies.circle(startX, startY, GRENADE_SIZE, {
      density: GRENADE_DENSITY, // Using density
      restitution: 0.6, // Bouncy
      friction: 0.1,
      frictionAir: 0.01,
      render: { fillStyle: GRENADE_COLOR } 
    });
    grenadeBody._id = grenadeId;
    grenadeBody._ownerId = peer ? peer.id : 'local';
    grenadeBody._throwTime = Date.now(); 
    grenadeBody._type = 'grenade'; 

    Body.setVelocity(grenadeBody, { 
      x: player.velocity.x + Math.cos(angle) * GRENADE_THROW_FORCE, 
      y: player.velocity.y + Math.sin(angle) * GRENADE_THROW_FORCE 
    });

    World.add(world, grenadeBody);
    activeGrenades.push(grenadeBody);

    // Network the grenade throw
    if (peer) {
      send({ 
        newGrenade: {
          id: grenadeId,
          ownerId: grenadeBody._ownerId,
          x: startX,
          y: startY,
          size: GRENADE_SIZE, // GRENADE_SIZE is a const, so it's fine
          density: GRENADE_DENSITY, // Send density if it can vary or for completeness
          velocity: grenadeBody.velocity,
          throwTime: grenadeBody._throwTime,
          angle: grenadeBody.angle, 
          color: GRENADE_COLOR // Send color if it can vary
        }
      });
    }
    playBeep(400, 0.1); // Throw sound
  }

  function triggerExplosion(sourceGrenade, isAuthoritative) {
    if (!sourceGrenade) return;

    console.log(`${isAuthoritative ? "Authoritative" : "Non-authoritative"} explosion for grenade: ${sourceGrenade._id}`);
    const explosionId = sourceGrenade._id + "_explosion_" + Date.now(); // Ensure unique explosion ID
    
    const explosionEffect = { 
      id: explosionId, 
      x: sourceGrenade.position.x, 
      y: sourceGrenade.position.y, 
      radius: 0, 
      maxRadius: GRENADE_EXPLOSION_RADIUS, 
      // Calculate speed to reach maxRadius in EXPLOSION_DURATION
      speed: GRENADE_EXPLOSION_RADIUS / (EXPLOSION_DURATION / (1000/60)), // Assuming 60fps
      color: EXPLOSION_COLOR, 
      startTime: Date.now(), 
      duration: EXPLOSION_DURATION, 
      ownerId: sourceGrenade._ownerId 
    };
    activeExplosions.push(explosionEffect);

    playBeep(100, 0.3); 
    playBeep(50, 0.2, 0.1); // Staggered low beep for rumble
    navigator.vibrate?.([100, 50, 100]);

    if (isAuthoritative) {
      // --- Damage and Force Application (Authoritative) ---
      const explosionCenter = { x: explosionEffect.x, y: explosionEffect.y };

      // Damage & Force Opponents
      Object.entries(opponents).forEach(([opponentId, opData]) => {
        if (opData.body && opData.state === 'alive') {
          const dist = Math.hypot(opData.body.position.x - explosionCenter.x, opData.body.position.y - explosionCenter.y);
          if (dist < GRENADE_EXPLOSION_RADIUS) {
            send({ 
              damageEvent: { 
                victimId: opponentId, 
                instigatorId: sourceGrenade._ownerId, 
                damageAmount: GRENADE_EXPLOSION_DAMAGE, 
                type: 'grenade_explosion' 
              } 
            });
            const angle = Math.atan2(opData.body.position.y - explosionCenter.y, opData.body.position.x - explosionCenter.x);
            const force = { x: Math.cos(angle) * GRENADE_EXPLOSION_FORCE_PLAYER, y: Math.sin(angle) * GRENADE_EXPLOSION_FORCE_PLAYER };
            Body.applyForce(opData.body, explosionCenter, force); 
          }
        }
      });

      // Damage & Force Self (Local Player)
      if (player && localPlayerState === 'alive') {
        const distToSelf = Math.hypot(player.position.x - explosionCenter.x, player.position.y - explosionCenter.y);
        if (distToSelf < GRENADE_EXPLOSION_RADIUS) {
          damagePlayer(sourceGrenade._ownerId, GRENADE_EXPLOSION_DAMAGE); // Assuming damagePlayer can take amount
          const angle = Math.atan2(player.position.y - explosionCenter.y, player.position.x - explosionCenter.x);
          const force = { x: Math.cos(angle) * GRENADE_EXPLOSION_FORCE_PLAYER, y: Math.sin(angle) * GRENADE_EXPLOSION_FORCE_PLAYER };
          Body.applyForce(player, explosionCenter, force);
        }
      }

      // Force on Interactive Blocks
      blocks.forEach(block => {
        if (block._isInteractive && block.body) { // Assuming block itself is the body
          const dist = Math.hypot(block.position.x - explosionCenter.x, block.position.y - explosionCenter.y);
          if (dist < GRENADE_EXPLOSION_RADIUS) {
            const angle = Math.atan2(block.position.y - explosionCenter.y, block.position.x - explosionCenter.x);
            const force = { x: Math.cos(angle) * GRENADE_EXPLOSION_FORCE_BLOCK, y: Math.sin(angle) * GRENADE_EXPLOSION_FORCE_BLOCK };
            Body.applyForce(block, explosionCenter, force);
          }
        }
      });

      send({ grenadeExploded: { grenadeId: sourceGrenade._id, explosion: explosionEffect } });
    }

    // Remove the grenade body from the world and active list
    World.remove(world, sourceGrenade);
    const index = activeGrenades.findIndex(g => g._id === sourceGrenade._id);
    if (index > -1) {
      activeGrenades.splice(index, 1);
    }
  }

  function throwStickyBomb() {
    if (!player || localPlayerState !== 'alive') return;

    // Aiming check is done in the click handler before calling this
    const angle = Math.atan2(lastRight.y, lastRight.x);
    const bombId = (peer ? peer.id : 'local') + "_sticky_" + Date.now();
    
    const startX = player.position.x + Math.cos(angle) * (size / 2 + STICKY_BOMB_SIZE);
    const startY = player.position.y + Math.sin(angle) * (size / 2 + STICKY_BOMB_SIZE);

    const bombBody = Bodies.circle(startX, startY, STICKY_BOMB_SIZE, {
      density: STICKY_BOMB_DENSITY,
      restitution: 0.2, 
      friction: 0.7, 
      frictionAir: 0.02,
      render: { fillStyle: STICKY_BOMB_COLOR }
    });
    bombBody._id = bombId;
    bombBody._ownerId = peer ? peer.id : 'local';
    bombBody._type = 'sticky_bomb';
    bombBody._isStuck = false;
    bombBody._stuckTo = null; 
    bombBody._stuckOffset = null; 

    Body.setVelocity(bombBody, { 
      x: player.velocity.x + Math.cos(angle) * STICKY_BOMB_THROW_FORCE, 
      y: player.velocity.y + Math.sin(angle) * STICKY_BOMB_THROW_FORCE 
    });

    World.add(world, bombBody);
    activeStickyBombs.push(bombBody);

    if (peer) {
      send({ 
        newStickyBomb: {
          id: bombId,
          ownerId: bombBody._ownerId,
          x: startX,
          y: startY,
          size: STICKY_BOMB_SIZE,
          density: STICKY_BOMB_DENSITY,
          velocity: bombBody.velocity,
          angle: bombBody.angle,
          color: STICKY_BOMB_COLOR,
          isStuck: bombBody._isStuck, 
          stuckTo: bombBody._stuckTo,
          stuckOffset: bombBody._stuckOffset
        }
      });
    }
    playBeep(450, 0.1); 
    updateDetonateButtonVisibility(); // Update button visibility after throwing
  }

  // Debug trigger for Invisibility
  window.addEventListener('keydown', (e) => {
    if ((e.key === 'i' || e.key === 'I') && localPlayerState === 'alive') {
      if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) {
        return; // Don't trigger if typing
      }
      activateInvisibility();
    }
  });

  // — Audio Unlock & Beeps —
  const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  let audioUnlocked=false;
  window.addEventListener('touchstart',()=>{
    if(!audioUnlocked){
      const buf=audioCtx.createBuffer(1,1,22050);
      const src=audioCtx.createBufferSource();
      src.buffer=buf; src.connect(audioCtx.destination); src.start(0);
      audioUnlocked=true;
    }
  },{once:true});
  function playBeep(freq,dur=0.1){
    const osc=audioCtx.createOscillator(), g=audioCtx.createGain();
    osc.frequency.value=freq; osc.connect(g); g.connect(audioCtx.destination);
    osc.start(); g.gain.setValueAtTime(1,audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+dur);
    osc.stop(audioCtx.currentTime+dur);
  }

  // — Networking (PeerJS) —
  // let conn; // Replaced by opponent.conn

  function send(customData = {}){ // customData can be e.g. {shoot: true, bullet: {...}}
    if (!peer || !peer.id) return; // Ensure peer is initialized
    const payload = Object.assign({
      senderId: peer.id,
      pos: [player.position.x, player.position.y], // Matter.js position
      angle: player.angle, // Matter.js body angle
      blocks: blocks.filter(b => b._isInteractive).map(b => ({ 
        id: b._id, 
        x: b.position.x, 
        y: b.position.y, 
        angle: b.angle,
        velocity: b.velocity,           // Send linear velocity
        angularVelocity: b.angularVelocity // Send angular velocity
      })),
      grenades: activeGrenades.map(g => ({ 
        id: g._id, 
        x: g.position.x, 
        y: g.position.y, 
        angle: g.angle, 
        velocity: g.velocity, 
        angularVelocity: g.angularVelocity 
      })),
      stickyBombs: activeStickyBombs.map(b => ({ 
        id: b._id, 
        x: b.position.x, 
        y: b.position.y, 
        angle: b.angle, 
        velocity: b.velocity, 
        angularVelocity: b.angularVelocity,
        isStuck: b._isStuck,      // Sync stick status
        stuckTo: b._stuckTo,      // Sync ID of object stuck to
        stuckOffset: b._stuckOffset // Sync offset if stuck
      })),
      // health: myHealth // Health is often sent specifically on change
    }, customData);

    Object.values(opponents).forEach(op => {
      if (op.conn && op.conn.open) {
        op.conn.send(payload);
      }
    });
  }

  function handleData(data, senderId){
    if (!senderId || !opponents[senderId]) {
      console.warn("Received data for unknown or disconnected opponent:", senderId, data);
      return;
    }
    const opponent = opponents[senderId];

    if(data.pos && opponent.body) Body.setPosition(opponent.body, { x:data.pos[0], y:data.pos[1] }); // Reverted
    if(data.angle != null && opponent.body) Body.setAngle(opponent.body, data.angle); // Reverted, assumes opponent.body.angle is used

    if (data.healthUpdate) { // Received a health update from a player
      const targetPlayerId = data.healthUpdate.targetId;
      const newHealth = data.healthUpdate.newHealth;
      if (targetPlayerId === peer.id) { // This should not happen if sent by self
        // myHealth = newHealth;
        // document.getElementById('myHealth').value = myHealth;
      } else if (opponents[targetPlayerId]) {
        opponents[targetPlayerId].health = newHealth;
        const healthBar = document.getElementById(`health-${targetPlayerId}`);
        if (healthBar) healthBar.value = newHealth;

        if (newHealth <= 0 && data.healthUpdate.instigatorId === peer.id) {
          if (!opponents[targetPlayerId].isDefeated) { // Check if already marked as defeated to prevent multiple kill counts
             myKills++;
             document.getElementById('myKills').textContent = myKills;
             console.log(`I defeated ${targetPlayerId}! Total kills: ${myKills}`);
             opponents[targetPlayerId].isDefeated = true; // Mark as defeated
          }
        }
      }
    }

    if (data.playerPowerUpdate && data.playerPowerUpdate.power === 'invisibility') {
      const targetId = data.playerPowerUpdate.targetId;
      const isActive = data.playerPowerUpdate.active;

      if (targetId === (peer ? peer.id : 'local')) {
        // This message is for the local player. While the local player manages their own
        // invisibility duration, this could act as an authoritative update or echo.
        // For now, we primarily rely on local state, but log it.
        console.log("Received invisibility update for local player:", isActive);
        // Potentially sync:
        // isInvisible = isActive;
        // if (isActive && data.playerPowerUpdate.duration) {
        //    invisibilityEndTime = Date.now() + data.playerPowerUpdate.duration;
        // } else if (!isActive) {
        //    invisibilityEndTime = 0;
        // }
      } else if (opponents[targetId]) {
        opponents[targetId].isInvisible = isActive;
        // Optional: Store end time for remote players if needed for other UI effects,
        // but for rendering, the boolean is the primary driver.
        // if (isActive && data.playerPowerUpdate.duration) {
        //     opponents[targetId].invisibilityEndTime = Date.now() + data.playerPowerUpdate.duration;
        // }
        console.log(`Opponent ${targetId} invisibility set to: ${isActive}`);
      }
    }

    if (data.damageEvent) { // Received a damage event
      const victimId = data.damageEvent.victimId;
      const instigatorId = data.damageEvent.instigatorId;
      // const damageAmount = data.damageEvent.damageAmount; // Assuming 1 damage per hit for now

      if (victimId === peer.id) { // Local player is the victim
        damagePlayer(instigatorId);
      }
      // Opponent processes their own damage.
    }

    if (data.playerState && opponents[data.playerState.targetId]) {
        const targetOpponent = opponents[data.playerState.targetId];
        targetOpponent.state = data.playerState.state;
        const opponentBody = targetOpponent.body;
        if (opponentBody) {
            if (data.playerState.state === 'dead') {
                Body.setStatic(opponentBody, true); // Corrected for Matter.js
                opponentBody.isSensor = true; // Make dead opponent's body a sensor
            } else if (data.playerState.state === 'alive') {
                Body.setStatic(opponentBody, false); // Corrected for Matter.js
                opponentBody.isSensor = false; // Restore as non-sensor
                // Position will be set by pos sync or a specific respawn message part
                if (data.playerState.isInvisible !== undefined) {
                    targetOpponent.isInvisible = data.playerState.isInvisible;
                } else {
                    targetOpponent.isInvisible = false; // Default to visible if not specified
                }
            }
        }
        console.log(`Opponent ${data.playerState.targetId} state changed to: ${data.playerState.state}`);
    }

    if(data.rematchSignal && senderId !== peer.id) { // Received rematch signal from an opponent
      console.log(`Received rematch signal from ${senderId}. Resetting game state.`);
      // Reset local player state to their initial spawn point
      myHealth = 5; // Max health
      localPlayerState = 'alive'; // Set local player to alive
      if(player) {
        Body.setStatic(player, false); // Matter.js
        player.isSensor = false; // Restore as non-sensor
      }

      document.getElementById('myHealth').value = myHealth;
      if(player) Body.setPosition(player, { x: spawnPoints[localPlayerSpawnIndex].x, y: spawnPoints[localPlayerSpawnIndex].y });
      if(player) Body.setVelocity(player, { x:0, y:0 });
      if(player) Body.setAngularVelocity(player, 0);
      if(player) {cam.x = player.position.x; cam.y = player.position.y;} // Recenter camera

      // Reset the signaling opponent's visual state to their spawn point
      const sigOpponent = opponents[senderId]; 
      if (sigOpponent) {
        sigOpponent.health = 5;
        sigOpponent.isDefeated = false;
        sigOpponent.state = 'alive'; // Set opponent to alive
        const healthBar = document.getElementById(`health-${senderId}`);
        if (healthBar) healthBar.value = 5;
        if (sigOpponent.body) {
            Body.setStatic(sigOpponent.body, false); // Matter.js
            sigOpponent.body.isSensor = false; // Restore as non-sensor
            const opSpawn = sigOpponent.spawnPoint || spawnPoints[1] || {x: WORLD_WIDTH - size, y: WORLD_HEIGHT/2}; // Fallback spawn
            Body.setPosition(sigOpponent.body, { x: opSpawn.x, y: opSpawn.y });
            Body.setVelocity(sigOpponent.body, { x:0, y:0 });
            Body.setAngularVelocity(sigOpponent.body, 0);
        }
      }
      // Note: All players receive the signal and reset themselves.
      // The positions of other non-signaling opponents will be updated via their regular position sync.

      bullets.forEach(b => World.remove(world, b)); // Reverted
      bullets.length=0;
      endOv.style.display='none'; // Hide end overlay if it was shown
    }

    if(data.shoot && data.bullet) spawnRemoteBullet(data.bullet, data.bullet.shooterId || data.senderId); // Ensure shooterId is passed

    // Block updates (less likely to change per player, but structure is here)
    if (data.blocks && senderId !== (peer ? peer.id : 'local')) { // Only process if data is from another peer
        data.blocks.forEach(bd => {
            const blockToUpdate = blocks.find(b => b._id === bd.id);
            // Assuming 'blocks' array stores Matter.js Body objects directly.
            // and these bodies have an '_isInteractive' property.
            if (blockToUpdate && blockToUpdate._isInteractive) { 
                Body.setPosition(blockToUpdate, { x: bd.x, y: bd.y });
                Body.setAngle(blockToUpdate, bd.angle);
                
                if (bd.velocity) {
                    Body.setVelocity(blockToUpdate, bd.velocity);
                }
                if (bd.angularVelocity !== undefined) { // angularVelocity can be 0, so check for undefined
                    Body.setAngularVelocity(blockToUpdate, bd.angularVelocity);
                }
            }
        });
    }

    if (data.newStickyBomb && data.senderId !== (peer ? peer.id : 'local')) {
      if (!activeStickyBombs.some(b => b._id === data.newStickyBomb.id)) {
        const bombData = data.newStickyBomb;
        const bombBody = Bodies.circle(bombData.x, bombData.y, bombData.size, {
          density: bombData.density || STICKY_BOMB_DENSITY,
          restitution: 0.2,
          friction: 0.7,
          frictionAir: 0.02,
          render: { fillStyle: bombData.color || STICKY_BOMB_COLOR }
        });
        bombBody._id = bombData.id;
        bombBody._ownerId = bombData.ownerId;
        bombBody._type = 'sticky_bomb';
        bombBody._isStuck = bombData.isStuck || false; // Ensure these are initialized
        bombBody._stuckTo = bombData.stuckTo || null;
        bombBody._stuckOffset = bombData.stuckOffset || null;

        Body.setPosition(bombBody, { x: bombData.x, y: bombData.y });
        Body.setVelocity(bombBody, bombData.velocity);
        Body.setAngle(bombBody, bombData.angle || 0);

        World.add(world, bombBody);
        activeStickyBombs.push(bombBody);
        console.log("Remote sticky bomb added:", bombData.id);
      }
    }

    if (data.stickyBombs && senderId !== (peer ? peer.id : 'local')) {
        data.stickyBombs.forEach(sbd => {
            let bombToUpdate = activeStickyBombs.find(b => b._id === sbd.id);
            if (bombToUpdate) {
                bombToUpdate._isStuck = sbd.isStuck;
                bombToUpdate._stuckTo = sbd.stuckTo;
                bombToUpdate._stuckOffset = sbd.stuckOffset;

                if (bombToUpdate._isStuck) {
                    if (!bombToUpdate.isStatic) { // Ensure it's static if stuck
                        Body.setStatic(bombToUpdate, true);
                    }
                    // Position for stuck bombs is handled by the main update() loop
                    // based on _stuckTo and _stuckOffset. We trust the local calculation
                    // for visual smoothness once the stuck state is known.
                    // If sbd contains an authoritative position from the owner even when stuck, use it:
                    // Body.setPosition(bombToUpdate, { x: sbd.x, y: sbd.y });
                    // Body.setAngle(bombToUpdate, sbd.angle); // And potentially angle
                } else {
                    if (bombToUpdate.isStatic) { // Ensure it's dynamic if not stuck
                        Body.setStatic(bombToUpdate, false);
                    }
                    // If not stuck, update all physics properties from sync
                    Body.setPosition(bombToUpdate, { x: sbd.x, y: sbd.y });
                    Body.setAngle(bombToUpdate, sbd.angle);
                    Body.setVelocity(bombToUpdate, sbd.velocity);
                    if (sbd.angularVelocity !== undefined) {
                       Body.setAngularVelocity(bombToUpdate, sbd.angularVelocity);
                    }
                }
            } else {
                // Sticky bomb doesn't exist locally, create it (e.g. if newStickyBomb message was missed)
                const newBombBody = Bodies.circle(sbd.x, sbd.y, sbd.size || STICKY_BOMB_SIZE, {
                    density: sbd.density || STICKY_BOMB_DENSITY,
                    restitution: 0.2,
                    friction: 0.7,
                    frictionAir: 0.02,
                    render: { fillStyle: sbd.color || STICKY_BOMB_COLOR }
                });
                newBombBody._id = sbd.id;
                newBombBody._ownerId = sbd.ownerId || senderId; // Guess owner if not provided
                newBombBody._type = 'sticky_bomb';
                newBombBody._isStuck = sbd.isStuck;
                newBombBody._stuckTo = sbd.stuckTo;
                newBombBody._stuckOffset = sbd.stuckOffset;

                Body.setPosition(newBombBody, {x: sbd.x, y: sbd.y});
                Body.setVelocity(newBombBody, sbd.velocity || {x:0, y:0}); // Default velocity if not provided
                Body.setAngle(newBombBody, sbd.angle || 0);
                 if (sbd.angularVelocity !== undefined) {
                    Body.setAngularVelocity(newBombBody, sbd.angularVelocity);
                }
                World.add(world, newBombBody);
                activeStickyBombs.push(newBombBody);
                console.log("Sticky bomb added from sync data:", sbd.id);
            }
        });
    }

    if (data.stickyBombStuck && data.senderId !== (peer ? peer.id : 'local')) {
        const bomb = activeStickyBombs.find(b => b._id === data.stickyBombStuck.bombId);
        if (bomb && !bomb._isStuck) { 
            bomb._isStuck = true;
            bomb._stuckTo = data.stickyBombStuck.stuckTo;
            bomb._stuckOffset = data.stickyBombStuck.offset;
            Body.setStatic(bomb, true); 
            
            // Optional: Immediately set position based on received data for quicker sync
            // This is helpful if the target entity's position is also synced reliably.
            if (data.stickyBombStuck.position) {
                 Body.setPosition(bomb, data.stickyBombStuck.position);
            }
            console.log(`Remote sticky bomb ${bomb._id} is now stuck.`);
        }
    }

    if (data.stickyBombUnstuck && data.senderId !== (peer ? peer.id : 'local')) {
        const bomb = activeStickyBombs.find(b => b._id === data.stickyBombUnstuck.bombId);
        if (bomb && bomb._isStuck) {
            bomb._isStuck = false;
            bomb._stuckTo = null;
            bomb._stuckOffset = null;
            Body.setStatic(bomb, false); 
            console.log(`Remote sticky bomb ${bomb._id} is now unstuck.`);
        }
    }

    if (data.stickyBombExploded) {
        const { bombId, explosion } = data.stickyBombExploded; // Ensure 'explosion' is the key used in sender
        const bomb = activeStickyBombs.find(b => b._id === bombId);

        if (bomb) {
            // Check if this client is not the owner, as owner already handled it.
            if (bomb._ownerId !== (peer ? peer.id : 'local')) {
                console.log(`Remote detonation for sticky bomb: ${bombId}`);
                initiateStickyBombDetonation(bomb, false); // Non-authoritative
            } else {
                 // Owner receiving its own explosion event. Bomb should already be removed by its own initiateStickyBombDetonation.
                 // This path primarily ensures button visibility is correct if somehow it wasn't updated.
                 updateDetonateButtonVisibility();
                 console.log("Owner received own stickyBombExploded event for:", bombId);
            }
        } else if (explosion && explosion.ownerId !== (peer ? peer.id : 'local')) {
            // Bomb not found locally, but explosion data exists (e.g. late join, or bomb removed too early by some other means)
            // Create visual effect only for the remote explosion.
            const remoteExplosion = { ...explosion }; // Clone to be safe
            remoteExplosion.startTime = Date.now(); // Start animation based on when we received it
            remoteExplosion.radius = 0; 
            // Calculate speed to reach maxRadius in EXPLOSION_DURATION
            remoteExplosion.speed = remoteExplosion.maxRadius / (remoteExplosion.duration / (1000 / 60)); // Assuming 60fps
            activeExplosions.push(remoteExplosion);
            
            playBeep(100, 0.3); 
            playBeep(50, 0.2, 0.1); // Explosion sound for remote
            console.log("Remote sticky bomb explosion effect created for bomb not found locally:", bombId);
            
            // Attempt to remove from world just in case it's there but not in activeStickyBombs
            const worldBomb = World.bodies.find(b => b._id === bombId);
            if(worldBomb) World.remove(world, worldBomb);
        }
    }

    if (data.grenadeExploded) { // Note: owner also receives this, but isAuthoritative handles it.
                               // Or, add: && data.senderId !== (peer ? peer.id : 'local') if owner should not re-process.
                               // For now, let's assume owner might get it but won't re-apply damage.
      const { grenadeId, explosion } = data.grenadeExploded;
      const originalGrenade = activeGrenades.find(g => g._id === grenadeId);

      if (originalGrenade && originalGrenade._ownerId !== (peer ? peer.id : 'local')) {
        // Trigger non-authoritative explosion for visual and local physics feedback
        triggerExplosion(originalGrenade, false); 
      } else if (!originalGrenade && explosion && explosion.ownerId !== (peer ? peer.id : 'local')) {
        // Grenade was already removed (e.g. by fuse locally), but we need to show remote explosion
        const remoteExplosion = { ...explosion }; // Clone
        remoteExplosion.startTime = Date.now(); // Start animation based on when we received it
        remoteExplosion.radius = 0; 
        // Calculate speed to reach maxRadius in EXPLOSION_DURATION
        remoteExplosion.speed = remoteExplosion.maxRadius / (remoteExplosion.duration / (1000/60));
        activeExplosions.push(remoteExplosion);
        
        playBeep(100, 0.3); 
        playBeep(50, 0.2, 0.1); 
        
        // Ensure the body is removed from world if it somehow still exists
        const gBody = World.bodies.find(b => b._id === grenadeId);
        if(gBody) World.remove(world, gBody);
        // And from activeGrenades array
        activeGrenades = activeGrenades.filter(gr => gr._id !== grenadeId);
        console.log("Remote explosion effect created for already removed grenade:", grenadeId);
      } else if (originalGrenade && originalGrenade._ownerId === (peer ? peer.id : 'local')) {
        // This is the owner receiving their own grenadeExploded message.
        // The grenade should have been removed by triggerExplosion already.
        // We can log or do nothing.
        console.log("Owner received own grenadeExploded event for:", grenadeId);
      }
    }

    if (data.newGrenade && data.senderId !== (peer ? peer.id : 'local')) {
      if (!activeGrenades.some(g => g._id === data.newGrenade.id)) { // Check if we already have this grenade
        const grenadeData = data.newGrenade;
        const grenadeBody = Bodies.circle(grenadeData.x, grenadeData.y, grenadeData.size, {
          density: grenadeData.density || GRENADE_DENSITY, // Use sent density or default
          restitution: 0.6,
          friction: 0.1,
          frictionAir: 0.01,
          render: { fillStyle: grenadeData.color || GRENADE_COLOR } // Use sent color or default
        });
        grenadeBody._id = grenadeData.id;
        grenadeBody._ownerId = grenadeData.ownerId;
        grenadeBody._throwTime = grenadeData.throwTime;
        grenadeBody._type = 'grenade';

        Body.setPosition(grenadeBody, { x: grenadeData.x, y: grenadeData.y });
        Body.setVelocity(grenadeBody, grenadeData.velocity);
        Body.setAngle(grenadeBody, grenadeData.angle || 0);

        World.add(world, grenadeBody);
        activeGrenades.push(grenadeBody);
        console.log("Remote grenade added:", grenadeData.id);
      }
    }

    if (data.grenades && senderId !== (peer ? peer.id : 'local')) {
        data.grenades.forEach(gd => {
            const grenadeToUpdate = activeGrenades.find(g => g._id === gd.id);
            if (grenadeToUpdate) {
                Body.setPosition(grenadeToUpdate, { x: gd.x, y: gd.y });
                Body.setAngle(grenadeToUpdate, gd.angle);
                Body.setVelocity(grenadeToUpdate, gd.velocity);
                if (gd.angularVelocity !== undefined) {
                    Body.setAngularVelocity(grenadeToUpdate, gd.angularVelocity);
                }
            } else {
                // Grenade doesn't exist locally, might be a latecomer, create it.
                // This logic is similar to newGrenade but uses the sync data.
                const newGrenadeBody = Bodies.circle(gd.x, gd.y, GRENADE_SIZE, { // Assuming GRENADE_SIZE is known
                    density: GRENADE_DENSITY, // Assuming default if not sent
                    restitution: 0.6,
                    friction: 0.1,
                    frictionAir: 0.01,
                    render: { fillStyle: GRENADE_COLOR } // Assuming default if not sent
                });
                newGrenadeBody._id = gd.id;
                newGrenadeBody._ownerId = gd.ownerId || senderId; // Guess owner if not provided in sync
                newGrenadeBody._throwTime = Date.now(); // Cannot know original throwTime from sync
                newGrenadeBody._type = 'grenade';

                Body.setPosition(newGrenadeBody, {x: gd.x, y: gd.y});
                Body.setVelocity(newGrenadeBody, gd.velocity);
                Body.setAngle(newGrenadeBody, gd.angle || 0);
                if (gd.angularVelocity !== undefined) {
                    Body.setAngularVelocity(newGrenadeBody, gd.angularVelocity);
                }
                World.add(world, newGrenadeBody);
                activeGrenades.push(newGrenadeBody);
                console.log("Grenade added from sync data:", gd.id);
            }
        });
    }
  }

  document.getElementById('initPeer').onclick=()=>{
    const myIdInput = document.getElementById('myId');
    const id = myIdInput.value.trim() || 'Player-' + Math.random().toString(36).substr(2, 4); // Generate random if empty
    myIdInput.value = id; // Update input field with actual ID used

    if (peer) peer.destroy(); // Clean up old peer object if any
    peer = new Peer(id);

    peer.on('open', openId => {
      document.getElementById('connStatus').textContent = `Your ID: ${openId}`;
      console.log('My peer ID is: ' + openId);
    });

    peer.on('connection', newConnection => {
      console.log(`New connection from ${newConnection.peer}`);
      setupOpponent(newConnection);
    });

    peer.on('error', err => {
      console.error("PeerJS error:", err);
      document.getElementById('connStatus').textContent = `Error: ${err.type || err.message}`;
    });
  };

  document.getElementById('connectPeer').onclick=()=>{
    if (!peer) return alert('Please initialize your Peer ID first (click Init).');
    const otherId = document.getElementById('otherId').value.trim();
    if (!otherId) return alert('Please enter an opponent\'s Peer ID.');
    if (opponents[otherId]) return alert('Already connected or connecting to this peer.');

    console.log(`Attempting to connect to ${otherId}`);
    const newConnection = peer.connect(otherId, { reliable: true });
    setupOpponent(newConnection);
  };

  function setupOpponent(conn) {
    const opponentId = conn.peer;
    if (opponents[opponentId] && opponents[opponentId].conn && opponents[opponentId].conn.open) {
      console.log(`Already have an open connection with ${opponentId}`);
      return;
    }

    console.log(`Setting up opponent: ${opponentId}`);
    const opponentSpawnPoint = spawnPoints[nextOpponentSpawnIndex % spawnPoints.length];
    // It's important that nextOpponentSpawnIndex is managed correctly,
    // potentially globally or passed around if multiple peers can initiate connections.
    // For now, this client will cycle its own index for opponents it sets up.
    nextOpponentSpawnIndex++;

    const newOpponentBody = Bodies.rectangle(
        opponentSpawnPoint.x, opponentSpawnPoint.y,
        size, size, { restitution: 0.2, frictionAir: 0.1 }
    );
    World.add(world, newOpponentBody);

    opponents[opponentId] = {
      body: newOpponentBody,
      health: 5, // Initial health
      conn: conn,
      // angle: 0, // Replaced by aimAngle on body itself
      spawnPoint: opponentSpawnPoint, // Store the spawn point
      isDefeated: false, // To track if kill has been counted for this opponent
      state: 'alive', // Initial state for opponent
      isInvisible: false // Initial invisibility state for opponent
    };

    // Add health bar for new opponent
    const uiContainer = document.getElementById('ui');
    const healthBarDiv = document.createElement('div');
    healthBarDiv.id = `opponent-ui-${opponentId}`;
    // Sanitize opponentId for display if necessary, though PeerJS IDs are generally safe.
    const displayName = opponentId.length > 8 ? opponentId.substring(0, 8) + "..." : opponentId;
    healthBarDiv.innerHTML = `Opponent ${displayName}: <progress id="health-${opponentId}" max="5" value="${opponents[opponentId].health}"></progress>`;
    uiContainer.appendChild(healthBarDiv);

    conn.on('open', () => {
      document.getElementById('connStatus').textContent = `Connected to ${opponentId}!`;
      console.log(`Connection to ${opponentId} opened.`);
      // Optional: Send initial handshake data including current health
      send({ greeting: "Hello from " + peer.id, healthUpdate: { targetId: peer.id, newHealth: myHealth } });

      // Voice chat setup for this connection
      navigator.mediaDevices.getUserMedia({audio:true})
        .then(stream => {
          const call = peer.call(opponentId, stream);
          if (call) call.on('stream', remoteStream => playStream(remoteStream, opponentId));
        })
        .catch(err => console.error("Failed to get media for call:", err));
    });

    conn.on('data', data => {
      // console.log("Received data from", opponentId, ":", data); // For debugging
      handleData(data, opponentId);
    });

    conn.on('close', () => {
      console.log(`Connection from ${opponentId} closed.`);
      if (opponents[opponentId]) {
        World.remove(world, opponents[opponentId].body);
        // Remove audio element if one was created for this opponent
        const audioEl = document.getElementById(`audio_${opponentId}`);
        if (audioEl) audioEl.remove();
        // Remove health bar
        const healthBarEl = document.getElementById(`opponent-ui-${opponentId}`);
        if (healthBarEl) healthBarEl.remove();
      }
      delete opponents[opponentId];
      document.getElementById('connStatus').textContent = `Disconnected from ${opponentId}.`;
    });

    conn.on('error', err => {
      console.error(`Connection error with ${opponentId}:`, err);
      if (opponents[opponentId]) {
         World.remove(world, opponents[opponentId].body);
         const healthBarEl = document.getElementById(`opponent-ui-${opponentId}`);
         if (healthBarEl) healthBarEl.remove();
      }
      delete opponents[opponentId];
      document.getElementById('connStatus').textContent = `Error with ${opponentId}: ${err.message}`;
    });
  }

  // Handle incoming calls
  if (peer) { // This check should be after peer initialization ideally, or ensure peer exists
    peer.on('call', call => {
      console.log(`Incoming call from ${call.peer}`);
      navigator.mediaDevices.getUserMedia({audio:true})
        .then(stream => {
          call.answer(stream); // Answer the call with an A/V stream.
          call.on('stream', remoteStream => playStream(remoteStream, call.peer));
        })
        .catch(err => console.error("Failed to get media for answering call:", err));
    });
  }

// — Bullet Collision Logic (Cannon.js) — // This is being removed.
// function bulletCollisionHandler(event) { ... } 


  function playStream(stream, peerId){
    const audioElId = `audio_${peerId}`;
    if (document.getElementById(audioElId)) return; // Already playing stream for this peer

    const a = document.createElement('audio');
    a.id = audioElId;
    a.srcObject = stream;
    a.autoplay = true;
    document.body.appendChild(a);
    console.log(`Playing audio from ${peerId}`);
  }

  // — Health & Kills —
  let myHealth = 5;
  let myKills = 0;
  let myKillCoins = 0;

  // Invisibility Power Variables
  let isInvisible = false;
  let invisibilityEndTime = 0;
  // Player's Held Power
  let currentHeldPower = null;
  // Grenade Variables & Constants
  let activeGrenades = [];
  const GRENADE_SIZE = 10;
  const GRENADE_DENSITY = 0.001; 
  const GRENADE_THROW_FORCE = 10; 
  const GRENADE_FUSE_TIME = 3000; // milliseconds (3 seconds)
  const GRENADE_EXPLOSION_RADIUS = 150;
  const GRENADE_EXPLOSION_DAMAGE = 2; // Amount of damage
  const GRENADE_EXPLOSION_FORCE_PLAYER = 0.1; // Specific force for players
  const GRENADE_EXPLOSION_FORCE_BLOCK = 0.08; // Specific force for blocks
  const GRENADE_COLOR = '#22dd22'; // Greenish
  
  let activeExplosions = []; // For visual explosion effects
  const EXPLOSION_COLOR = 'rgba(255, 100, 0, 0.7)';
  const EXPLOSION_DURATION = 500; // ms, for visual effect

  // Sticky Bomb Variables & Constants
  let activeStickyBombs = [];
  const STICKY_BOMB_SIZE = 8;
  const STICKY_BOMB_DENSITY = 0.4; 
  const STICKY_BOMB_THROW_FORCE = 12;
  const STICKY_BOMB_COLOR = '#00cc00'; // Green

  // Shockwave Power Variables
  let activeShockwaves = [];
  const SHOCKWAVE_MAX_RADIUS = 300;
  const SHOCKWAVE_SPEED = 10; // Pixels per update cycle
  const SHOCKWAVE_COLOR_SELF = 'rgba(0, 150, 255, 0.5)';  // Blueish for self
  const SHOCKWAVE_COLOR_OTHER = 'rgba(255, 100, 0, 0.5)'; // Orangish for others

  function damagePlayer(instigatorId = null, damageAmount = 1){ // instigatorId is the peerId of the shooter, default damage 1
    if (myHealth <= 0) return; // Already defeated

    myHealth -= damageAmount;
    document.getElementById('myHealth').value = myHealth;
    cam.shake = 20; navigator.vibrate?.(100);

    if(myHealth <= 0) {
      localPlayerState = 'dead';
      currentHeldPower = null; // Reset held power on death
      document.getElementById('heldPowerDisplay').style.display = 'none'; // Hide display
      document.getElementById('heldPowerDisplay').textContent = '';      // Clear content
      console.log("Player died, currentHeldPower reset, display hidden.");
      showEnd('You Died');
      // The instigator (if any) will see the healthUpdate and increment their kill count.
      
      // Make player's body static for Matter.js
      if (player && !player.isStatic) { // Check if player body exists and not already static
          Body.setStatic(player, true);
          player.isSensor = true; // Make dead player's body a sensor
      }
      // Inform others about my new health AND state
      send({ 
          healthUpdate: { targetId: peer.id, newHealth: myHealth, instigatorId: instigatorId },
          playerState: { targetId: peer.id, state: 'dead' } 
      });
    } else {
      // Inform others about my new health (still alive)
      send({ healthUpdate: { targetId: peer.id, newHealth: myHealth, instigatorId: instigatorId } });
    }
  }

  // In handleData, when receiving healthUpdate for an opponent:
  // if (data.healthUpdate && data.healthUpdate.newHealth <= 0) {
  //   const victimId = data.healthUpdate.targetId;
  //   const killerId = data.healthUpdate.instigatorId;
  //   if (killerId === peer.id && opponents[victimId]) { // I was the instigator
  //       myKills++;
  //       document.getElementById('myKills').textContent = myKills;
  //       console.log(`I defeated ${victimId}! Total kills: ${myKills}`);
  //   }
  // }
  // This logic is now integrated into the healthUpdate part of handleData.

  Events.on(engine,'collisionStart',ev=>{ // Restoring Matter.js collision logic
    ev.pairs.forEach(p=>{
      const [bodyA, bodyB] = [p.bodyA, p.bodyB];

      // Bullet collision logic (existing)
      if (player && !player.isSensor) { 
        if(bullets.includes(bodyA) && bodyB === player){ removeBullet(bodyA._id); damagePlayer(bodyA.shooterId || null); } 
        if(bullets.includes(bodyB) && bodyA === player){ removeBullet(bodyB._id); damagePlayer(bodyB.shooterId || null); } 
      }
      Object.values(opponents).forEach(op => {
        if (op && op.body && !op.body.isSensor) { 
          let bulletHit = null;
          if (bullets.includes(bodyA) && bodyB === op.body) bulletHit = bodyA; 
          if (bullets.includes(bodyB) && bodyA === op.body) bulletHit = bodyB;
          if (bulletHit) {
            removeBullet(bulletHit._id);
            if (bulletHit.shooterId === (peer ? peer.id : "local")) { 
               send({ damageEvent: { victimId: op.conn.peer, instigatorId: (peer ? peer.id : "local"), damageAmount: 1, bulletId: bulletHit._id } });
            }
          }
        }
      });

      // Sticky Bomb Sticking Logic
      let bombBody, targetBody, targetType, targetIdValue;

      if (bodyA._type === 'sticky_bomb' && !bodyA._isStuck) {
        bombBody = bodyA;
        targetBody = bodyB;
      } else if (bodyB._type === 'sticky_bomb' && !bodyB._isStuck) {
        bombBody = bodyB;
        targetBody = bodyA;
      }

      if (bombBody) {
        // Determine target type
        if (targetBody === player) {
          targetType = 'player';
          targetIdValue = peer ? peer.id : 'local';
        } else {
          const opponentEntry = Object.entries(opponents).find(([id, opData]) => opData.body === targetBody);
          if (opponentEntry) {
            targetType = 'opponent';
            targetIdValue = opponentEntry[0]; // This is the opponent's peerId
          } else {
            const blockEntry = blocks.find(b => b === targetBody);
            if (blockEntry) {
              targetType = blockEntry._isInteractive ? 'interactive_block' : 'static_block';
              targetIdValue = blockEntry._id;
            }
          }
        }

        if (targetType) { // If it's a valid target to stick to
          bombBody._isStuck = true;
          Body.setStatic(bombBody, true); // Make bomb static so it moves with the target
          bombBody._stuckTo = { type: targetType, id: targetIdValue };
          bombBody._stuckOffset = { 
            x: bombBody.position.x - targetBody.position.x, 
            y: bombBody.position.y - targetBody.position.y 
          };
          
          console.log(`Sticky bomb ${bombBody._id} stuck to ${targetType} ${targetIdValue}`);
          playBeep(300, 0.05); // Stick sound

          if (bombBody._ownerId === (peer ? peer.id : 'local')) {
            send({ 
              stickyBombStuck: { 
                bombId: bombBody._id, 
                stuckTo: bombBody._stuckTo, 
                offset: bombBody._stuckOffset,
                position: bombBody.position // Send current position for immediate remote update
              } 
            });
          }
        }
      }
    });
  });

  // // In spawnRemoteBullet, tag bullet with shooterId // OLD MATTER.JS FUNCTION - REMOVED
  // function spawnRemoteBullet(bd, shooterId){ 
  //   if(bullets.some(b=>b._id===bd.id)) return;
  //   const bullet = Bodies.circle(bd.x, bd.y, 5, { restitution:0.8, frictionAir:0.02, density:0.001 });
  //   bullet._id = bd.id;
  //   bullet.shooterId = shooterId; 
  //   Body.setVelocity(bullet, { x:bd.vx, y:bd.vy });
  //   bullets.push(bullet);
  //   World.add(world, bullet);
  //   setTimeout(()=>removeBullet(bd.id), 3500);
  // }

  // // Modify shoot function to include shooterId (local player's ID) // OLD MATTER.JS FUNCTION - REMOVED
  // function shoot(isLocal){
  //   const angle = Math.atan2(lastRight.y, lastRight.x);
  //   const bid   = peer.id + "_" + bulletCounter++; 
  //   const bx = player.position.x + Math.cos(angle)*(size/2+5);
  //   const by = player.position.y + Math.sin(angle)*(size/2+5);
  //   const bullet = Bodies.circle(bx, by, 5, { restitution:0.8, frictionAir:0.02, density:0.001 });
  //   bullet._id = bid;
  //   bullet.shooterId = peer ? peer.id : "local"; 
  //   Body.setVelocity(bullet, { x:Math.cos(angle)*15, y:Math.sin(angle)*15 });
  //   bullets.push(bullet);
  //   World.add(world, bullet);
  //   setTimeout(()=>removeBullet(bullet._id), 3500); 
  //   if(isLocal && peer) send({ shoot:true, bullet:{ id:bullet._id, x:bx, y:by, vx:bullet.velocity.x, vy:bullet.velocity.y, shooterId: bullet.shooterId }}); 
  //   playBeep(600,0.05);
  //   navigator.vibrate?.(20);
  // }

  // Modify handleData for 'shoot' event to pass shooterId to spawnRemoteBullet
  // In handleData:
  // if(data.shoot && data.bullet) spawnRemoteBullet(data.bullet, data.senderId);
  // This is already implicitly handled if spawnRemoteBullet takes senderId. Let's make it explicit.
  // The 'data.senderId' is the peer who sent the message (the shooter).
  // The 'data.bullet.shooterId' is who the sender claims shot the bullet (should be themselves).
  // Sticking to data.senderId as the shooter of the bullet for remote bullets.

  // Refined section in handleData:
  // if(data.shoot && data.bullet) spawnRemoteBullet(data.bullet, data.senderId);


  // — Inventory Toggle —
  document.getElementById('inventory').onclick=()=>{
    const d=document.getElementById('inventoryDetails');
    d.style.display = d.style.display==='block'?'none':'block';
  };

  // — Start / End UI & Loop —
  document.getElementById('startGame').onclick=()=>{
    document.getElementById('startOverlay').style.display='none';
    // send({}); // Initial send might not be needed if using greeting or relying on first update
  };
  const endOv=document.getElementById('endOverlay'), endMsg=document.getElementById('endMsg');
  function showEnd(msg){ 
      endMsg.textContent=msg; 
      endOv.style.display='flex'; 
      if (msg === 'You Died') {
          document.getElementById('rematch').style.display = 'none'; // Hide rematch if dead
          document.getElementById('respawnButton').style.display = 'inline-block'; // Show respawn
      } else {
          document.getElementById('rematch').style.display = 'inline-block'; // Show rematch for other end conditions
          document.getElementById('respawnButton').style.display = 'none';
      }
  }

  document.getElementById('rematch').onclick=()=>{
    myHealth = 5; myKills = 0; currentHeldPower = null; // Reset local player stats including held power
    localPlayerState = 'alive';
    document.getElementById('heldPowerDisplay').style.display = 'none'; // Hide display
    document.getElementById('heldPowerDisplay').textContent = '';      // Clear content
    console.log("Rematch, currentHeldPower reset, display hidden.");
    if(player) {
        Body.setStatic(player, false); // Matter.js
        player.isSensor = false; // Restore as non-sensor
    }

    document.getElementById('myHealth').value = myHealth;
    document.getElementById('myKills').textContent = '0';
    if(player) {
      Body.setPosition(player, { x: spawnPoints[localPlayerSpawnIndex].x, y: spawnPoints[localPlayerSpawnIndex].y }); 
      Body.setVelocity(player, { x:0, y:0 }); 
      Body.setAngularVelocity(player, 0); 
    }

    // For opponents, their health reset will be communicated via network messages.
    // Or, a specific "rematch" signal could be sent.
    Object.keys(opponents).forEach(opId => { 
      const op = opponents[opId];
      if (op && op.body) { 
        op.state = 'alive'; // Opponent is also alive on rematch
        Body.setStatic(op.body, false); // Matter.js
        op.body.isSensor = false; // Restore as non-sensor
        const opSpawnPoint = op.spawnPoint || { x: WORLD_WIDTH - size, y: WORLD_HEIGHT / 2 }; 
        Body.setPosition(op.body, { x: opSpawnPoint.x, y: opSpawnPoint.y }); 
        Body.setVelocity(op.body, { x:0, y:0 }); 
        Body.setAngularVelocity(op.body, 0); 
        const healthBar = document.getElementById(`health-${op.conn.peer}`);
        if (healthBar) healthBar.value = 5;
        op.health = 5;
        op.isDefeated = false; 
      }
    });
    // Send rematch signal along with current player's alive state
    send({ 
        rematchSignal: true, 
        playerState: { targetId: peer ? peer.id : 'local', state: 'alive' },
        pos: player ? [player.position.x, player.position.y] : [spawnPoints[localPlayerSpawnIndex].x, spawnPoints[localPlayerSpawnIndex].y],
        healthUpdate: {targetId: peer ? peer.id : 'local', newHealth: myHealth }
        // shooterId might not be needed in rematchSignal itself, but rather when bullets are created
    }); 

    bullets.forEach(b => World.remove(world, b)); // Reverted
    bullets.length=0;
    endOv.style.display='none';
    send({ health:myHealth });
  };

  document.getElementById('respawnButton').onclick = () => {
      if (localPlayerState !== 'dead') return; // Only allow respawn if dead

      localPlayerState = 'alive';
      myHealth = 5; // Reset health (use max health constant if available)
      document.getElementById('myHealth').value = myHealth;

      // Reset invisibility state
      isInvisible = false;
      invisibilityEndTime = 0;
      // currentHeldPower is intentionally NOT reset here as per requirements

      // Restore player body physics
      if (player) { // Ensure player body exists
        Body.setStatic(player, false); // Matter.js
        player.isSensor = false; // Restore as non-sensor
      }

      // Move player to a spawn point
      const spawnPoint = spawnPoints[localPlayerSpawnIndex]; // Or a random one
      if (player && spawnPoint) { // Ensure both exist
        Body.setPosition(player, { x: spawnPoint.x, y: spawnPoint.y });
        Body.setVelocity(player, { x:0, y:0 });
        Body.setAngularVelocity(player, 0);
      }
            
      // Update camera
      if (player) { // Ensure player exists for camera update
        cam.x = player.position.x;
        cam.y = player.position.y;
      }

      // Send respawn state to others
      if (peer && player) { // Ensure peer and player exist for sending data
        send({ 
            playerState: { 
                targetId: peer.id, 
                state: 'alive',
                isInvisible: false // Explicitly state player is visible on respawn
            },
            pos: [player.position.x, player.position.y], // Send current position
            healthUpdate: { targetId: peer.id, newHealth: myHealth } // Send current health
        });
      }
            
      endOv.style.display='none'; // Hide the overlay
      document.getElementById('rematch').style.display = 'inline-block'; // Restore rematch button visibility
  };

  function update(){
    if (player && localPlayerState === 'alive') { // Only apply velocity if player exists and is alive
        Body.setVelocity(player,{ x:leftStick.x*6, y:leftStick.y*6 }); 
    }
    
    // player.aimAngle update removed, assuming player.angle (physics body angle) will be used or aiming is visual only.
    // If aiming needs to rotate the physics body, Body.setAngle(player, newAngle) would be used here.
    // For now, sticking to original Matter.js behavior where player.angle is physics driven.

    // Update active shockwaves
    for (let i = activeShockwaves.length - 1; i >= 0; i--) {
      const sw = activeShockwaves[i];
      sw.radius += sw.speed;

      // --- Shockwave Collision/Effect Logic (only for locally owned shockwaves) ---
      if (sw.ownerId === (peer ? peer.id : 'local')) {
        // Opponent Interaction
        Object.entries(opponents).forEach(([opponentId, opData]) => {
          if (opData.body && opData.state === 'alive' && !sw.affectedEntities.has(opponentId)) {
            const dist = Math.hypot(opData.body.position.x - sw.x, opData.body.position.y - sw.y);
            if (dist < sw.radius && dist > (sw.radius - sw.speed * 2) ) { // Check within current expansion band
              // Send damage event
              send({ 
                damageEvent: { 
                  victimId: opponentId, 
                  instigatorId: peer.id, 
                  damageAmount: 1, // Or a specific shockwave damage amount
                  type: 'shockwave' 
                } 
              });

              // Apply force locally for visual feedback
              const angle = Math.atan2(opData.body.position.y - sw.y, opData.body.position.x - sw.x);
              const forceMagnitude = 0.05; // Adjust as needed, consider opponent mass
              const force = { x: Math.cos(angle) * forceMagnitude, y: Math.sin(angle) * forceMagnitude };
              Body.applyForce(opData.body, { x: sw.x, y: sw.y }, force); // Apply force at shockwave center relative to opponent

              sw.affectedEntities.add(opponentId);
            }
          }
        });

        // Interactive Block Interaction
        blocks.forEach(block => {
          if (block._isInteractive && block.body && !sw.affectedEntities.has(block._id)) { // Ensure block.body exists
            const dist = Math.hypot(block.position.x - sw.x, block.position.y - sw.y);
             // Check within current expansion band, and also ensure block is not too close to center (already passed)
            if (dist < sw.radius && dist > (sw.radius - sw.speed * 2) ) { 
              const blockForceMagnitude = 0.03; // Adjust as needed, consider block mass
              const angle = Math.atan2(block.position.y - sw.y, block.position.x - sw.x);
              const force = { x: Math.cos(angle) * blockForceMagnitude, y: Math.sin(angle) * blockForceMagnitude };
              Body.applyForce(block, { x: sw.x, y: sw.y }, force);

              sw.affectedEntities.add(block._id);
            }
          }
        });
      }
      // --- End Shockwave Collision/Effect Logic ---

      if (sw.radius >= sw.maxRadius) {
        activeShockwaves.splice(i, 1); // Remove shockwave if it reached max radius
      }
    }

    // Update Invisibility State
    if (isInvisible && Date.now() >= invisibilityEndTime) {
      isInvisible = false;
      if (peer) {
        send({ 
          playerPowerUpdate: { 
            targetId: peer.id, 
            power: 'invisibility', 
            active: false 
          } 
        });
      }
      console.log("Invisibility ended at:", new Date().toLocaleTimeString());
    }

    // Update active sticky bombs (maintain position if stuck)
    activeStickyBombs.forEach(bomb => {
      if (bomb._isStuck && bomb._stuckTo) {
        let targetEntityBody = null;
        if (bomb._stuckTo.type === 'player' && bomb._stuckTo.id === (peer ? peer.id : 'local')) {
          targetEntityBody = player;
        } else if (bomb._stuckTo.type === 'opponent') {
          const op = opponents[bomb._stuckTo.id];
          if (op && op.body) targetEntityBody = op.body;
        } else if (bomb._stuckTo.type === 'interactive_block' || bomb._stuckTo.type === 'static_block') {
          targetEntityBody = blocks.find(b => b._id === bomb._stuckTo.id);
        }

        if (targetEntityBody) {
          const newPos = { 
            x: targetEntityBody.position.x + bomb._stuckOffset.x, 
            y: targetEntityBody.position.y + bomb._stuckOffset.y 
          };
          Body.setPosition(bomb, newPos);
          // Body.setAngle(bomb, targetEntityBody.angle); // Match angle if desired, might cause visual spinning if parent spins
        } else {
          // Target entity disappeared or not found, unstick the bomb
          bomb._isStuck = false;
          bomb._stuckTo = null;
          bomb._stuckOffset = null;
          Body.setStatic(bomb, false); // Make it dynamic again
          console.log(`Sticky bomb ${bomb._id} unstuck because target disappeared.`);
          if (bomb._ownerId === (peer ? peer.id : 'local')) {
            send({ stickyBombUnstuck: { bombId: bomb._id } });
          }
        }
      }
    });

    // Update active grenades (fuse timer)
    for (let i = activeGrenades.length - 1; i >= 0; i--) {
        const g = activeGrenades[i];
        if (g._isExploding) continue; // Already marked for explosion, skip further checks

        if (Date.now() > g._throwTime + GRENADE_FUSE_TIME) {
            if (g._ownerId === (peer ? peer.id : 'local')) { // Only owner triggers the authoritative explosion
                if (!g._isExploding) { // Prevent multiple triggers if somehow re-evaluated
                    g._isExploding = true; // Mark as processing explosion
                    triggerExplosion(g, true); // true for authoritative
                }
            }
            // Non-owners will have their grenades removed when they receive the 'grenadeExploded' event.
            // However, if an owner's grenade message is lost, other clients might keep the grenade too long.
            // A fallback timeout for non-owned grenades could be added here if necessary,
            // e.g., remove if significantly past fuse time and no explosion event received.
        }
    }
    // Filter out grenades that have been marked as exploded and processed by triggerExplosion (for owner)
    // or by network event (for non-owners, handled in handleData for grenadeExploded).
    // This specific filtering might be better handled directly where grenades are removed (triggerExplosion/handleData).

    // Update visual explosions
    for (let i = activeExplosions.length - 1; i >= 0; i--) {
        const exp = activeExplosions[i];
        exp.radius += exp.speed;
        if (Date.now() > exp.startTime + exp.duration) {
            activeExplosions.splice(i, 1);
        }
    }

    if (player) { // Ensure player exists before trying to access its properties for camera
       cam.x=player.position.x; 
       cam.y=player.position.y;
    }
    Engine.update(engine,1000/60); 
    if (peer && peer.open) send({}); // Send updates only if peer connection is open
    render();
    requestAnimationFrame(update);
  }

  // const euler = new CANNON.Vec3(); // Removed as it's for Cannon.js quaternions
  function render(){
    applyCamera();

    // Render visual explosions
    activeExplosions.forEach(exp => {
      ctx.beginPath();
      ctx.arc(exp.x, exp.y, exp.radius, 0, 2 * Math.PI);
      ctx.fillStyle = exp.color;
      ctx.fill();
    });

    // draw blocks
    blocks.forEach(b=>{
      ctx.save();
      ctx.translate(b.position.x, b.position.y);
      ctx.rotate(b.angle); // Reverted to Matter.js angle
      
      // Color logic based on _isInteractive or isStatic (original way)
      if (b._isInteractive) {
        ctx.fillStyle = '#888'; 
      } else if (b.isStatic) { // Matter.js uses isStatic
        ctx.fillStyle = '#555'; 
      } else { 
        ctx.fillStyle = '#AAA'; // Fallback
      }
      // Original renderSize logic might be needed if it varied for non-static blocks
      const renderSize = b.isStatic ? blockSize : (b.render && b.render.sprite && b.render.sprite.xScale ? blockSize * b.render.sprite.xScale : blockSize);
      ctx.fillRect(-renderSize/2, -renderSize/2, renderSize, renderSize);
      ctx.restore();
    });
    // draw players
    // Draw local player
    if (localPlayerState === 'alive' && !isInvisible) { // Don't draw if invisible
        ctx.save();
        ctx.translate(player.position.x, player.position.y);
        ctx.rotate(player.angle); // Reverted to Matter.js player.angle
        ctx.fillStyle = '#4af'; // Local player color
        ctx.fillRect(-size/2, -size/2, size, size);
        ctx.restore();
    }

    // Draw opponents
    Object.values(opponents).forEach(op => {
      // Check if opponent, its body, and its state exist, and if state is not 'dead' AND not invisible
      if (op && op.body && op.state !== 'dead' && !op.isInvisible) { 
        ctx.save();
        ctx.translate(op.body.position.x, op.body.position.y);
        ctx.rotate(op.body.angle); // Reverted to Matter.js op.body.angle
        ctx.fillStyle = '#fa4'; // Opponent color
        ctx.fillRect(-size/2, -size/2, size, size);
        ctx.restore();
      }
    });
    // draw bullets
    bullets.forEach(b=>{
      ctx.beginPath();
      ctx.arc(b.position.x, b.position.y, 5, 0, 2*Math.PI);
      ctx.fillStyle='#fff'; ctx.fill();
    });
    // draw blue world border
    ctx.lineWidth=4/scale;
    ctx.strokeStyle='blue';
    ctx.strokeRect(0,0,WORLD_WIDTH, WORLD_HEIGHT);
  }

  // — Item Shop Logic —
  const shopItems = [
    { id: 'shockwave', name: 'Shockwave', cost: 1, emoji: '💥', description: 'Unleash a force blast.' },
    { id: 'invisibility', name: 'Invisibility (5s)', cost: 1, emoji: '👻', description: 'Become unseen for 5 seconds.' },
    { id: 'grenade', name: 'Grenade', cost: 2, emoji: '💣', description: 'Explodes after a short fuse.' },
    { id: 'sticky_bomb', name: 'Sticky Bomb', cost: 3, emoji: '🟢', description: 'Sticks to surfaces! Detonate remotely.' }
    // Add more items here as they are implemented
  ];

  const shopItemsContainer = document.getElementById('shopItemsContainer');
  const itemShopOverlay = document.getElementById('itemShopOverlay');
  const shopKillCoinsDisplay = document.getElementById('shopKillCoinsDisplay');

  function populateShopItems() {
    if (!shopItemsContainer) return;
    shopItemsContainer.innerHTML = ''; // Clear existing items

    shopItems.forEach(item => {
      const itemElement = document.createElement('div');
      itemElement.classList.add('shop-item');
      itemElement.innerHTML = `${item.emoji} ${item.name} <br>Cost: ${item.cost} <span title="${item.description}">ℹ️</span>`;
      itemElement.onclick = () => {
        purchaseItem(item.id, item.cost);
      };
      shopItemsContainer.appendChild(itemElement);
    });
  }

  function purchaseItem(itemId, itemCost) {
    if (currentHeldPower !== null) {
      alert("You already have a power equipped! Use it or lose it before buying another.");
      return;
    }

    if (myKillCoins >= itemCost) {
      myKillCoins -= itemCost;
      currentHeldPower = itemId;

      // Update kill coin displays
      document.getElementById('myKillCoinsDisplay').textContent = myKillCoins;
      if (itemShopOverlay.style.display === 'flex') { // Check if shop is open before updating its display
          shopKillCoinsDisplay.textContent = myKillCoins;
      }

      console.log(`Purchased ${itemId}. Current power: ${currentHeldPower}. Coins left: ${myKillCoins}`);
      playBeep(700, 0.1); // Purchase success sound
      playBeep(1000, 0.1, 0.05);

      // Update held power display
      const itemDetails = shopItems.find(shopItem => shopItem.id === itemId);
      const heldPowerDisplay = document.getElementById('heldPowerDisplay');
      if (itemDetails && itemDetails.emoji && heldPowerDisplay) {
        heldPowerDisplay.textContent = itemDetails.emoji;
        heldPowerDisplay.style.display = 'flex';
      }

      // Close the shop automatically
      itemShopOverlay.style.display = 'none';
    } else {
      alert("Not enough Kill Coins!");
      playBeep(150, 0.2); // Not enough coins sound
    }
  }

  function updateDetonateButtonVisibility() {
    const detonateButton = document.getElementById('detonateStickyButton');
    if (!detonateButton) return;

    const localStickyBombsExist = activeStickyBombs.some(b => b._ownerId === (peer ? peer.id : 'local') && !b._isExploding); // Also check if not already exploding
    detonateButton.style.display = localStickyBombsExist ? 'inline-block' : 'none';
  }

  // Initial population of shop items
  populateShopItems();

  // Shop Toggle Button Listener
  const toggleShopBtn = document.getElementById('toggleShopButton');
  if (toggleShopBtn) {
    toggleShopBtn.onclick = () => {
      const shopOverlay = document.getElementById('itemShopOverlay');
      if (shopOverlay.style.display === 'flex') {
        shopOverlay.style.display = 'none';
      } else {
        // Update kill coins display in shop before showing
        document.getElementById('shopKillCoinsDisplay').textContent = myKillCoins;
        shopOverlay.style.display = 'flex';
      }
    };
  }

  // Detonate Sticky Bomb Button Listener
  const detonateButton = document.getElementById('detonateStickyButton');
  if (detonateButton) {
    detonateButton.onclick = () => {
      if (localPlayerState !== 'alive') return;

      // Find the oldest active sticky bomb owned by the local player
      let oldestBomb = null;
      for (let i = 0; i < activeStickyBombs.length; i++) {
        const bomb = activeStickyBombs[i];
        if (bomb._ownerId === (peer ? peer.id : 'local') && !bomb._isExploding) {
          if (!oldestBomb || bomb._throwTime < oldestBomb._throwTime) {
            oldestBomb = bomb;
          }
        }
      }

      if (oldestBomb) {
        console.log(`Player manually detonating sticky bomb: ${oldestBomb._id}`);
        initiateStickyBombDetonation(oldestBomb, true); // Authoritative detonation
        // updateDetonateButtonVisibility(); // Called inside initiateStickyBombDetonation
      } else {
        console.log("No local sticky bombs to detonate.");
        updateDetonateButtonVisibility(); // Should hide the button if no bombs are actually available
      }
    };
  }

  // Click listener for Held Power Display
  const heldPowerDisplayElement = document.getElementById('heldPowerDisplay');
  if (heldPowerDisplayElement) {
    heldPowerDisplayElement.onclick = () => {
      if (currentHeldPower && localPlayerState === 'alive') {
        console.log(`Activating power: ${currentHeldPower}`);
        let powerActivated = false;
        if (currentHeldPower === 'shockwave') {
          activateShockwave();
          powerActivated = true;
        } else if (currentHeldPower === 'invisibility') {
          activateInvisibility();
          powerActivated = true;
        } else if (currentHeldPower === 'grenade') {
          if (lastRight.x === 0 && lastRight.y === 0) {
            alert("Please aim with the right joystick before throwing a grenade.");
            return; 
          }
          throwGrenade();
          powerActivated = true;
        } else if (currentHeldPower === 'sticky_bomb') {
          if (lastRight.x === 0 && lastRight.y === 0) {
            alert("Please aim with the right joystick before deploying a sticky bomb!");
            return;
          }
          throwStickyBomb();
          powerActivated = true;
        }
        // Add more power activations here with else if (currentHeldPower === 'someOtherPower')

        if (powerActivated) {
          currentHeldPower = null;
          heldPowerDisplayElement.style.display = 'none';
          heldPowerDisplayElement.textContent = '';
          playBeep(900, 0.15); // Power activation sound
        }
      } else if (!currentHeldPower) {
        console.log("No power held to activate.");
      } else if (localPlayerState !== 'alive') {
        console.log("Cannot activate power while not alive.");
      }
    };
  }

  update();
  // document.body.addEventListener('touchmove',e=>e.preventDefault(),{ passive:false }); // Original page scroll prevention
  </script>
</body>
</html>

[end of index.html]

[end of index.html]

[end of index.html]

[end of index.html]
