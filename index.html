<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2D Shooter – Fixed World Bounds</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; touch-action:none; background:#000; }
    canvas { display:block; background:#222; margin:auto; }
    /* Overlays */
    #startOverlay, #endOverlay {
      position:absolute; top:0; left:0; right:0; bottom:0;
      background:rgba(0,0,0,0.9); color:white;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      font-family:sans-serif; z-index:100;
    }
    #endOverlay { display:none; }
    #startOverlay h1 { font-size:3em; margin-bottom:0.5em; }
    #startOverlay label { font-size:1.2em; margin:0.5em 0; }
    #startOverlay input[type="text"] { font-size:1.2em; padding:0.5em; width:250px; }
    #startOverlay button { font-size:1.3em; padding:0.6em 1em; margin:0.5em; }
    #sliderContainer { margin-top:1em; text-align:center; }
    #sliderContainer input[type="range"] { width:300px; }
    /* HUD */
    #ui { position:absolute; top:10px; left:10px; color:white; z-index:5; font-family:sans-serif; }
    #ui div { margin-bottom:4px; }
    /* Inventory */
    #inventory { position:absolute; top:10px; right:10px; width:50px; height:50px;
      background:rgba(0,0,0,0.5); color:white; font-size:1.5em;
      display:flex; align-items:center; justify-content:center;
      border:2px solid #fff; border-radius:4px; cursor:pointer; z-index:5; }
    #inventoryDetails {
      position:absolute; top:70px; right:10px;
      background:rgba(0,0,0,0.8); color:white; padding:10px;
      border:2px solid #fff; border-radius:4px; display:none; z-index:5;
      font-family:sans-serif;
    }
    /* Joystick zones */
    .joystick-zone { position:absolute; z-index:5; bottom:20px; }
    #leftZone { left:20px; } #rightZone{ right:20px; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <!-- Start / End Overlays -->
  <div id="startOverlay">
    <h1>2D Shooter</h1>
    <label>Your ID: <input id="myId" type="text" placeholder="peer‑id"></label>
    <button id="initPeer">Init</button>
    <label>Connect to: <input id="otherId" type="text" placeholder="peer‑id"></label>
    <button id="connectPeer">Connect</button>
    <button id="startGame">Start</button>
    <div id="connStatus" style="margin-top:0.5em; font-size:1em;"></div>
    <div id="sliderContainer">
      <label for="jSize">Joystick Size: <span id="jSizeVal">150</span>px</label><br>
      <input id="jSize" type="range" min="100" max="300" value="150">
    </div>
  </div>

  <div id="endOverlay">
    <h1 id="endMsg"></h1>
    <button id="rematch">Rematch</button>
    <button id="respawnButton" style="display: none;">Respawn</button>
  </div>

  <!-- HUD -->
  <div id="ui">
    <div>You: <progress id="myHealth" max="5" value="5"></progress></div>
    <!-- Opponent health bars will be added here dynamically -->
  </div>

  <!-- Inventory -->
  <div id="inventory">I</div>
  <div id="inventoryDetails">
    <strong>Inventory</strong><br>
    Bullets: ∞<br>
    Blocks: interactive<br>
    Kills: <span id="myKills">0</span>
  </div>

  <!-- Joysticks -->
  <div id="leftZone" class="joystick-zone"></div>
  <div id="rightZone" class="joystick-zone"></div>

  <script>
  // — Virtual World Constants —
  const WORLD_WIDTH  = 2400;
  const WORLD_HEIGHT = 2400;
  const CAMERA_ZOOM_OUT_FACTOR = 0.75; // Less than 1 zooms out, shows more.

  // — Canvas & Matter Setup —
  const canvas = document.getElementById('game');
  const ctx    = canvas.getContext('2d');
  let cw=window.innerWidth, ch=window.innerHeight;
  canvas.width = cw; canvas.height = ch;

  const { Engine, World, Bodies, Body, Events, Vector } = Matter;
  const engine = Engine.create(), world = engine.world;
  world.gravity.y = 0; // Original Matter.js gravity setting

  // — Compute uniform scale & letterbox offsets —
  let scale=1, xOffset=0, yOffset=0;
  function updateViewport(){
    cw=window.innerWidth; ch=window.innerHeight;
    // Which dimension constrains the world?
    scale = Math.min(cw/WORLD_WIDTH, ch/WORLD_HEIGHT) * CAMERA_ZOOM_OUT_FACTOR;
    // compute letterboxing centering
    xOffset = (cw - WORLD_WIDTH * scale) / 2;
    yOffset = (ch - WORLD_HEIGHT * scale) / 2;
    canvas.width = cw; canvas.height = ch;
  }
  window.addEventListener('resize', updateViewport);
  updateViewport();

  // — Camera (follows player) —
  let cam = { x: WORLD_WIDTH/2, y: WORLD_HEIGHT/2, shake:0 };
  function applyCamera(){
    ctx.setTransform(1,0,0,1,0,0);
    // clear letterbox
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,cw,ch);
    // apply letterbox + scale
    ctx.translate(xOffset, yOffset);
    ctx.scale(scale, scale);
    // apply camera shake & centering
    const sx = (Math.random()-0.5)*cam.shake;
    const sy = (Math.random()-0.5)*cam.shake;
    ctx.translate(-cam.x + WORLD_WIDTH/2 + sx, -cam.y + WORLD_HEIGHT/2 + sy);
    cam.shake = Math.max(0, cam.shake * 0.9);
  }

  // — World Borders (fixed coords) —
  const borders = [
      Bodies.rectangle(WORLD_WIDTH/2, -10, WORLD_WIDTH, 20, { isStatic:true }),
      Bodies.rectangle(WORLD_WIDTH/2, WORLD_HEIGHT+10, WORLD_WIDTH, 20, { isStatic:true }),
      Bodies.rectangle(-10, WORLD_HEIGHT/2, 20, WORLD_HEIGHT, { isStatic:true }),
      Bodies.rectangle(WORLD_WIDTH+10, WORLD_HEIGHT/2, 20, WORLD_HEIGHT, { isStatic:true })
  ];
  World.add(world, borders);

  // — Map Data Parsing —
  function parseMapData(mapString) {
    const blocksData = [];
    if (!mapString || typeof mapString !== 'string') {
      return blocksData; // Return empty if input is invalid
    }
    const blockTokens = mapString.split('-');
    for (const token of blockTokens) {
      let isInteractive = false;
      let coordString = token;
      if (token.startsWith('i')) {
        isInteractive = true;
        coordString = token.substring(1);
      }
      const parts = coordString.split(',');
      if (parts.length === 2) {
        const x = parseInt(parts[0], 10);
        const y = parseInt(parts[1], 10);
        if (!isNaN(x) && !isNaN(y)) {
          blocksData.push({ x, y, isInteractive });
        }
      }
    }
    return blocksData;
  }

  // — Player & Other Entities —
  const size = 40; // Player size
  const spawnPoints = [
    { x: 100, y: WORLD_HEIGHT / 2 },
    { x: WORLD_WIDTH - 100, y: WORLD_HEIGHT / 2 },
    { x: WORLD_WIDTH / 2, y: 100 },
    { x: WORLD_WIDTH / 2, y: WORLD_HEIGHT - 100 },
    { x: 200, y: 200 },
    { x: WORLD_WIDTH - 200, y: WORLD_HEIGHT - 200 }
  ];
  let localPlayerSpawnIndex = 0; // Local player always takes the first spawn point

  const player = Bodies.rectangle(
      spawnPoints[localPlayerSpawnIndex].x,
      spawnPoints[localPlayerSpawnIndex].y,
      size, size, { restitution:0.2, frictionAir:0.1 } // Original properties
  );
  World.add(world, player);

  // Initial camera position update was missing in the previous attempt; it's part of applyCamera or cam object init.
  // Let's ensure cam is initialized correctly. The cam object is already global.
  // We'll set its initial x,y after player is created.
  cam.x = player.position.x;
  cam.y = player.position.y;

  let localPlayerState = 'alive'; // Player state: 'alive', 'dead'
  let opponents = {}; // Stores opponent data, keyed by peerId
  let peer; // Local PeerJS instance
  let nextOpponentSpawnIndex = 1; // Index for the next opponent's spawn point (starts from 1 as player takes 0)


  // — Blocks (from map string) —
  const blocks = []; // Array to hold all blocks for rendering and networking
  const mapString = "5,5-10,10-i15,15-20,20-i25,25-5,15-15,5"; // Example: grid coords
  const gridCellSize = 50; // Each grid cell is 50x50 pixels
  const blockSize = 50; // Visual size of the block

  const parsedBlocks = parseMapData(mapString);

  parsedBlocks.forEach((blockData, index) => {
    const pixelX = blockData.x * gridCellSize + blockSize / 2; // Center block in grid cell
    const pixelY = blockData.y * gridCellSize + blockSize / 2; // Center block in grid cell
    let blockBody;

    if (blockData.isInteractive) {
      blockBody = Bodies.rectangle(pixelX, pixelY, blockSize, blockSize, {
        restitution: 0.8,
        frictionAir: 0.02,
        density: 0.002, // Example Matter.js property
        _isInteractive: true, 
        render: { fillStyle: '#888' } 
      });
    } else {
      blockBody = Bodies.rectangle(pixelX, pixelY, blockSize, blockSize, {
        isStatic: true,
        _isInteractive: false, 
        render: { fillStyle: '#555' }
      });
    }

    blockBody._id = "map_block_" + index; // Unique ID
    blocks.push(blockBody);
  });

  World.add(world, blocks); // Add all new blocks to the world

  // — Bullets & IDs & Lifespan —
  const bullets = [];
  let bulletCounter = 0;
  function removeBullet(id){
    const idx = bullets.findIndex(b=>b._id===id);
    if(idx>=0){
      World.remove(world, bullets[idx]); // Reverted
      bullets.splice(idx,1);
    }
  }

  function shoot(isLocal){
    const angle = Math.atan2(lastRight.y, lastRight.x);
    // const bid   = bulletCounter++; // Original
    const bid = (peer && peer.id ? peer.id + "_" : "local_") + bulletCounter++; // Keep unique ID for now
    const bx = player.position.x + Math.cos(angle)*(size/2+5);
    const by = player.position.y + Math.sin(angle)*(size/2+5);
    const bullet = Bodies.circle(bx, by, 5, { restitution:0.8, frictionAir:0.02, density:0.001 }); // Matter.js
    bullet._id = bid;
    bullet.shooterId = peer ? peer.id : "local"; // Keep shooterId logic
    Body.setVelocity(bullet, { x:Math.cos(angle)*15, y:Math.sin(angle)*15 }); // Matter.js
    bullets.push(bullet);
    World.add(world, bullet); // Matter.js
    // schedule auto‑dispersion
    setTimeout(()=>removeBullet(bullet._id), 3500);
    // network - ensure vx, vy are from Matter.js body.velocity
    if(isLocal && peer) send({ shoot:true, bullet:{ id:bullet._id, x:bx, y:by, vx:bullet.velocity.x, vy:bullet.velocity.y, shooterId: bullet.shooterId }});
    // feedback
    playBeep(600,0.05);
    navigator.vibrate?.(20);
  }

  function spawnRemoteBullet(bd, shooterId){ // shooterId is the sender of the shoot message
    if(bullets.some(b=>b._id===bd.id)) return;
    const bullet = Bodies.circle(bd.x, bd.y, 5, { restitution:0.8, frictionAir:0.02, density:0.001 }); // Matter.js
    bullet._id = bd.id;
    bullet.shooterId = shooterId; // Assign from passed shooterId
    Body.setVelocity(bullet, { x:bd.vx, y:bd.vy }); // Matter.js
    bullets.push(bullet);
    World.add(world, bullet); // Matter.js
    setTimeout(()=>removeBullet(bd.id), 3500);
  }

  // — Joysticks & Touch —
  let leftStick={x:0,y:0}, lastRight={x:0,y:0};
  let joystickSize=150, leftMgr, rightMgr;
  function createJoysticks(sz){
    if(leftMgr) leftMgr.destroy();
    if(rightMgr)rightMgr.destroy();
    ['leftZone','rightZone'].forEach(id=>{
      const el=document.getElementById(id);
      el.style.width=sz+'px'; el.style.height=sz+'px';
    });
    leftMgr  = nipplejs.create({ zone:document.getElementById('leftZone'), mode:'static', position:{ left:'50%', top:'50%' }, size:sz });
    rightMgr = nipplejs.create({ zone:document.getElementById('rightZone'),mode:'static', position:{ left:'50%', top:'50%' }, size:sz });
    leftMgr.on('move',(_,d)=>{ leftStick.x=d.vector.x; leftStick.y=-d.vector.y; })
           .on('end',()=>{ leftStick.x=0; leftStick.y=0; });
    rightMgr.on('move',(_,d)=>{ lastRight.x=d.vector.x; lastRight.y=-d.vector.y; })
            .on('end',()=>{ if(Math.hypot(lastRight.x,lastRight.y)>0.2) shoot(true); lastRight.x=0; lastRight.y=0; });
  }
  document.getElementById('jSize').addEventListener('input',e=>{
    joystickSize=+e.target.value;
    document.getElementById('jSizeVal').textContent=joystickSize;
    createJoysticks(joystickSize);
  });
  createJoysticks(joystickSize);

  canvas.addEventListener('touchstart',ev=>{
    const t=ev.touches[0];
    if(t.clientY > ch*0.6){
      const dx=t.clientX - (player.position.x*scale + xOffset);
      const dy=t.clientY - (player.position.y*scale + yOffset);
      lastRight.x = dx/Math.hypot(dx,dy);
      lastRight.y = dy/Math.hypot(dx,dy);
      shoot(true);
    }
  });

  // — Audio Unlock & Beeps —
  const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  let audioUnlocked=false;
  window.addEventListener('touchstart',()=>{
    if(!audioUnlocked){
      const buf=audioCtx.createBuffer(1,1,22050);
      const src=audioCtx.createBufferSource();
      src.buffer=buf; src.connect(audioCtx.destination); src.start(0);
      audioUnlocked=true;
    }
  },{once:true});
  function playBeep(freq,dur=0.1){
    const osc=audioCtx.createOscillator(), g=audioCtx.createGain();
    osc.frequency.value=freq; osc.connect(g); g.connect(audioCtx.destination);
    osc.start(); g.gain.setValueAtTime(1,audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+dur);
    osc.stop(audioCtx.currentTime+dur);
  }

  // — Networking (PeerJS) —
  // let conn; // Replaced by opponent.conn

  function send(customData = {}){ // customData can be e.g. {shoot: true, bullet: {...}}
    if (!peer || !peer.id) return; // Ensure peer is initialized
    const payload = Object.assign({
      senderId: peer.id,
      pos: [player.position.x, player.position.y], // Matter.js position
      angle: player.angle, // Matter.js body angle
      // blocks: blocks.map(b=>({ id:b._id, x:b.position.x, y:b.position.y, angle:b.angle })), // Original block sync example
      // health: myHealth // Health is often sent specifically on change
    }, customData);

    Object.values(opponents).forEach(op => {
      if (op.conn && op.conn.open) {
        op.conn.send(payload);
      }
    });
  }

  function handleData(data, senderId){
    if (!senderId || !opponents[senderId]) {
      console.warn("Received data for unknown or disconnected opponent:", senderId, data);
      return;
    }
    const opponent = opponents[senderId];

    if(data.pos && opponent.body) Body.setPosition(opponent.body, { x:data.pos[0], y:data.pos[1] }); // Reverted
    if(data.angle != null && opponent.body) Body.setAngle(opponent.body, data.angle); // Reverted, assumes opponent.body.angle is used

    if (data.healthUpdate) { // Received a health update from a player
      const targetPlayerId = data.healthUpdate.targetId;
      const newHealth = data.healthUpdate.newHealth;
      if (targetPlayerId === peer.id) { // This should not happen if sent by self
        // myHealth = newHealth;
        // document.getElementById('myHealth').value = myHealth;
      } else if (opponents[targetPlayerId]) {
        opponents[targetPlayerId].health = newHealth;
        const healthBar = document.getElementById(`health-${targetPlayerId}`);
        if (healthBar) healthBar.value = newHealth;

        if (newHealth <= 0 && data.healthUpdate.instigatorId === peer.id) {
          if (!opponents[targetPlayerId].isDefeated) { // Check if already marked as defeated to prevent multiple kill counts
             myKills++;
             document.getElementById('myKills').textContent = myKills;
             console.log(`I defeated ${targetPlayerId}! Total kills: ${myKills}`);
             opponents[targetPlayerId].isDefeated = true; // Mark as defeated
          }
        }
      }
    }

    if (data.damageEvent) { // Received a damage event
      const victimId = data.damageEvent.victimId;
      const instigatorId = data.damageEvent.instigatorId;
      // const damageAmount = data.damageEvent.damageAmount; // Assuming 1 damage per hit for now

      if (victimId === peer.id) { // Local player is the victim
        damagePlayer(instigatorId);
      }
      // Opponent processes their own damage.
    }

    if (data.playerState && opponents[data.playerState.targetId]) {
        const targetOpponent = opponents[data.playerState.targetId];
        targetOpponent.state = data.playerState.state;
        const opponentBody = targetOpponent.body;
        if (opponentBody) {
            if (data.playerState.state === 'dead') {
                Body.setStatic(opponentBody, true); // Corrected for Matter.js
                opponentBody.isSensor = true; // Make dead opponent's body a sensor
            } else if (data.playerState.state === 'alive') {
                Body.setStatic(opponentBody, false); // Corrected for Matter.js
                opponentBody.isSensor = false; // Restore as non-sensor
                // Position will be set by pos sync or a specific respawn message part
            }
        }
        console.log(`Opponent ${data.playerState.targetId} state changed to: ${data.playerState.state}`);
    }

    if(data.rematchSignal && senderId !== peer.id) { // Received rematch signal from an opponent
      console.log(`Received rematch signal from ${senderId}. Resetting game state.`);
      // Reset local player state to their initial spawn point
      myHealth = 5; // Max health
      localPlayerState = 'alive'; // Set local player to alive
      if(player) {
        Body.setStatic(player, false); // Matter.js
        player.isSensor = false; // Restore as non-sensor
      }

      document.getElementById('myHealth').value = myHealth;
      if(player) Body.setPosition(player, { x: spawnPoints[localPlayerSpawnIndex].x, y: spawnPoints[localPlayerSpawnIndex].y });
      if(player) Body.setVelocity(player, { x:0, y:0 });
      if(player) Body.setAngularVelocity(player, 0);
      if(player) {cam.x = player.position.x; cam.y = player.position.y;} // Recenter camera

      // Reset the signaling opponent's visual state to their spawn point
      const sigOpponent = opponents[senderId]; 
      if (sigOpponent) {
        sigOpponent.health = 5;
        sigOpponent.isDefeated = false;
        sigOpponent.state = 'alive'; // Set opponent to alive
        const healthBar = document.getElementById(`health-${senderId}`);
        if (healthBar) healthBar.value = 5;
        if (sigOpponent.body) {
            Body.setStatic(sigOpponent.body, false); // Matter.js
            sigOpponent.body.isSensor = false; // Restore as non-sensor
            const opSpawn = sigOpponent.spawnPoint || spawnPoints[1] || {x: WORLD_WIDTH - size, y: WORLD_HEIGHT/2}; // Fallback spawn
            Body.setPosition(sigOpponent.body, { x: opSpawn.x, y: opSpawn.y });
            Body.setVelocity(sigOpponent.body, { x:0, y:0 });
            Body.setAngularVelocity(sigOpponent.body, 0);
        }
      }
      // Note: All players receive the signal and reset themselves.
      // The positions of other non-signaling opponents will be updated via their regular position sync.

      bullets.forEach(b => World.remove(world, b)); // Reverted
      bullets.length=0;
      endOv.style.display='none'; // Hide end overlay if it was shown
    }

    if(data.shoot && data.bullet) spawnRemoteBullet(data.bullet, data.bullet.shooterId || data.senderId); // Ensure shooterId is passed

    // Block updates (less likely to change per player, but structure is here)
    if(data.blocks){ // Block positions are also Vec3 in Cannon.js, assuming Z is blockSize/2
      data.blocks.forEach(bd=>{
        const b=blocks.find(x=>x._id===bd.id);
        if(b){ 
          b.position.set(bd.x,bd.y, blockSize/2); 
          // For angle, Cannon.js uses quaternions. If bd.angle is Euler Z:
          b.quaternion.setFromEuler(0, 0, bd.angle || 0); 
        }
      });
    }
  }

  document.getElementById('initPeer').onclick=()=>{
    const myIdInput = document.getElementById('myId');
    const id = myIdInput.value.trim() || 'Player-' + Math.random().toString(36).substr(2, 4); // Generate random if empty
    myIdInput.value = id; // Update input field with actual ID used

    if (peer) peer.destroy(); // Clean up old peer object if any
    peer = new Peer(id);

    peer.on('open', openId => {
      document.getElementById('connStatus').textContent = `Your ID: ${openId}`;
      console.log('My peer ID is: ' + openId);
    });

    peer.on('connection', newConnection => {
      console.log(`New connection from ${newConnection.peer}`);
      setupOpponent(newConnection);
    });

    peer.on('error', err => {
      console.error("PeerJS error:", err);
      document.getElementById('connStatus').textContent = `Error: ${err.type || err.message}`;
    });
  };

  document.getElementById('connectPeer').onclick=()=>{
    if (!peer) return alert('Please initialize your Peer ID first (click Init).');
    const otherId = document.getElementById('otherId').value.trim();
    if (!otherId) return alert('Please enter an opponent\'s Peer ID.');
    if (opponents[otherId]) return alert('Already connected or connecting to this peer.');

    console.log(`Attempting to connect to ${otherId}`);
    const newConnection = peer.connect(otherId, { reliable: true });
    setupOpponent(newConnection);
  };

  function setupOpponent(conn) {
    const opponentId = conn.peer;
    if (opponents[opponentId] && opponents[opponentId].conn && opponents[opponentId].conn.open) {
      console.log(`Already have an open connection with ${opponentId}`);
      return;
    }

    console.log(`Setting up opponent: ${opponentId}`);
    const opponentSpawnPoint = spawnPoints[nextOpponentSpawnIndex % spawnPoints.length];
    // It's important that nextOpponentSpawnIndex is managed correctly,
    // potentially globally or passed around if multiple peers can initiate connections.
    // For now, this client will cycle its own index for opponents it sets up.
    nextOpponentSpawnIndex++;

    const newOpponentBody = Bodies.rectangle(
        opponentSpawnPoint.x, opponentSpawnPoint.y,
        size, size, { restitution: 0.2, frictionAir: 0.1 }
    );
    World.add(world, newOpponentBody);

    opponents[opponentId] = {
      body: newOpponentBody,
      health: 5, // Initial health
      conn: conn,
      // angle: 0, // Replaced by aimAngle on body itself
      spawnPoint: opponentSpawnPoint, // Store the spawn point
      isDefeated: false, // To track if kill has been counted for this opponent
      state: 'alive' // Initial state for opponent
    };

    // Add health bar for new opponent
    const uiContainer = document.getElementById('ui');
    const healthBarDiv = document.createElement('div');
    healthBarDiv.id = `opponent-ui-${opponentId}`;
    // Sanitize opponentId for display if necessary, though PeerJS IDs are generally safe.
    const displayName = opponentId.length > 8 ? opponentId.substring(0, 8) + "..." : opponentId;
    healthBarDiv.innerHTML = `Opponent ${displayName}: <progress id="health-${opponentId}" max="5" value="${opponents[opponentId].health}"></progress>`;
    uiContainer.appendChild(healthBarDiv);

    conn.on('open', () => {
      document.getElementById('connStatus').textContent = `Connected to ${opponentId}!`;
      console.log(`Connection to ${opponentId} opened.`);
      // Optional: Send initial handshake data including current health
      send({ greeting: "Hello from " + peer.id, healthUpdate: { targetId: peer.id, newHealth: myHealth } });

      // Voice chat setup for this connection
      navigator.mediaDevices.getUserMedia({audio:true})
        .then(stream => {
          const call = peer.call(opponentId, stream);
          if (call) call.on('stream', remoteStream => playStream(remoteStream, opponentId));
        })
        .catch(err => console.error("Failed to get media for call:", err));
    });

    conn.on('data', data => {
      // console.log("Received data from", opponentId, ":", data); // For debugging
      handleData(data, opponentId);
    });

    conn.on('close', () => {
      console.log(`Connection from ${opponentId} closed.`);
      if (opponents[opponentId]) {
        World.remove(world, opponents[opponentId].body);
        // Remove audio element if one was created for this opponent
        const audioEl = document.getElementById(`audio_${opponentId}`);
        if (audioEl) audioEl.remove();
        // Remove health bar
        const healthBarEl = document.getElementById(`opponent-ui-${opponentId}`);
        if (healthBarEl) healthBarEl.remove();
      }
      delete opponents[opponentId];
      document.getElementById('connStatus').textContent = `Disconnected from ${opponentId}.`;
    });

    conn.on('error', err => {
      console.error(`Connection error with ${opponentId}:`, err);
      if (opponents[opponentId]) {
         World.remove(world, opponents[opponentId].body);
         const healthBarEl = document.getElementById(`opponent-ui-${opponentId}`);
         if (healthBarEl) healthBarEl.remove();
      }
      delete opponents[opponentId];
      document.getElementById('connStatus').textContent = `Error with ${opponentId}: ${err.message}`;
    });
  }

  // Handle incoming calls
  if (peer) { // This check should be after peer initialization ideally, or ensure peer exists
    peer.on('call', call => {
      console.log(`Incoming call from ${call.peer}`);
      navigator.mediaDevices.getUserMedia({audio:true})
        .then(stream => {
          call.answer(stream); // Answer the call with an A/V stream.
          call.on('stream', remoteStream => playStream(remoteStream, call.peer));
        })
        .catch(err => console.error("Failed to get media for answering call:", err));
    });
  }

// — Bullet Collision Logic (Cannon.js) — // This is being removed.
// function bulletCollisionHandler(event) { ... } 


  function playStream(stream, peerId){
    const audioElId = `audio_${peerId}`;
    if (document.getElementById(audioElId)) return; // Already playing stream for this peer

    const a = document.createElement('audio');
    a.id = audioElId;
    a.srcObject = stream;
    a.autoplay = true;
    document.body.appendChild(a);
    console.log(`Playing audio from ${peerId}`);
  }

  // — Health & Kills —
  let myHealth = 5;
  let myKills = 0;

  function damagePlayer(instigatorId = null){ // instigatorId is the peerId of the shooter
    if (myHealth <= 0) return; // Already defeated

    myHealth--;
    document.getElementById('myHealth').value = myHealth;
    cam.shake = 20; navigator.vibrate?.(100);

    if(myHealth <= 0) {
      localPlayerState = 'dead';
      showEnd('You Died');
      // The instigator (if any) will see the healthUpdate and increment their kill count.
      
      // Make player's body static for Matter.js
      if (player && !player.isStatic) { // Check if player body exists and not already static
          Body.setStatic(player, true);
          player.isSensor = true; // Make dead player's body a sensor
      }
      // Inform others about my new health AND state
      send({ 
          healthUpdate: { targetId: peer.id, newHealth: myHealth, instigatorId: instigatorId },
          playerState: { targetId: peer.id, state: 'dead' } 
      });
    } else {
      // Inform others about my new health (still alive)
      send({ healthUpdate: { targetId: peer.id, newHealth: myHealth, instigatorId: instigatorId } });
    }
  }

  // In handleData, when receiving healthUpdate for an opponent:
  // if (data.healthUpdate && data.healthUpdate.newHealth <= 0) {
  //   const victimId = data.healthUpdate.targetId;
  //   const killerId = data.healthUpdate.instigatorId;
  //   if (killerId === peer.id && opponents[victimId]) { // I was the instigator
  //       myKills++;
  //       document.getElementById('myKills').textContent = myKills;
  //       console.log(`I defeated ${victimId}! Total kills: ${myKills}`);
  //   }
  // }
  // This logic is now integrated into the healthUpdate part of handleData.

  Events.on(engine,'collisionStart',ev=>{ // Restoring Matter.js collision logic
    ev.pairs.forEach(p=>{
      const [A,B] = [p.bodyA, p.bodyB];
      // Local player hit by a bullet.
      // Assumes bullet has shooterId property
      if (player && !player.isSensor) { // Check if player is not a sensor
        if(bullets.includes(A) && B === player){ removeBullet(A._id); damagePlayer(A.shooterId || null); } 
        if(bullets.includes(B) && A === player){ removeBullet(B._id); damagePlayer(B.shooterId || null); } 
      }

      // Opponent hit by a bullet (sent by local player)
      Object.values(opponents).forEach(op => {
        if (op && op.body && !op.body.isSensor) { // Check if opponent body exists and is not a sensor
          let bulletHit = null;
          // let hitOpponentBody = null; // Not strictly needed if only op.body is used for checks
          if (bullets.includes(A) && B === op.body) bulletHit = A; 
          if (bullets.includes(B) && A === op.body) bulletHit = B;

          if (bulletHit) {
            removeBullet(bulletHit._id);
            // Send a damage event if this client's bullet hit an opponent
            if (bulletHit.shooterId === (peer ? peer.id : "local")) { 
               send({ damageEvent: { victimId: op.conn.peer, instigatorId: (peer ? peer.id : "local"), damageAmount: 1, bulletId: bulletHit._id } });
            }
          }
        }
      });
    });
    // This line was present in an older version of collision handler. If myKills is purely client-side based on direct hits, it might be okay.
    // However, kills are now determined by receiving a healthUpdate where newHealth <=0 and this client was the instigator.
    // document.getElementById('myKills').textContent = myKills; 
  });

  // // In spawnRemoteBullet, tag bullet with shooterId // OLD MATTER.JS FUNCTION - REMOVED
  // function spawnRemoteBullet(bd, shooterId){ 
  //   if(bullets.some(b=>b._id===bd.id)) return;
  //   const bullet = Bodies.circle(bd.x, bd.y, 5, { restitution:0.8, frictionAir:0.02, density:0.001 });
  //   bullet._id = bd.id;
  //   bullet.shooterId = shooterId; 
  //   Body.setVelocity(bullet, { x:bd.vx, y:bd.vy });
  //   bullets.push(bullet);
  //   World.add(world, bullet);
  //   setTimeout(()=>removeBullet(bd.id), 3500);
  // }

  // // Modify shoot function to include shooterId (local player's ID) // OLD MATTER.JS FUNCTION - REMOVED
  // function shoot(isLocal){
  //   const angle = Math.atan2(lastRight.y, lastRight.x);
  //   const bid   = peer.id + "_" + bulletCounter++; 
  //   const bx = player.position.x + Math.cos(angle)*(size/2+5);
  //   const by = player.position.y + Math.sin(angle)*(size/2+5);
  //   const bullet = Bodies.circle(bx, by, 5, { restitution:0.8, frictionAir:0.02, density:0.001 });
  //   bullet._id = bid;
  //   bullet.shooterId = peer ? peer.id : "local"; 
  //   Body.setVelocity(bullet, { x:Math.cos(angle)*15, y:Math.sin(angle)*15 });
  //   bullets.push(bullet);
  //   World.add(world, bullet);
  //   setTimeout(()=>removeBullet(bullet._id), 3500); 
  //   if(isLocal && peer) send({ shoot:true, bullet:{ id:bullet._id, x:bx, y:by, vx:bullet.velocity.x, vy:bullet.velocity.y, shooterId: bullet.shooterId }}); 
  //   playBeep(600,0.05);
  //   navigator.vibrate?.(20);
  // }

  // Modify handleData for 'shoot' event to pass shooterId to spawnRemoteBullet
  // In handleData:
  // if(data.shoot && data.bullet) spawnRemoteBullet(data.bullet, data.senderId);
  // This is already implicitly handled if spawnRemoteBullet takes senderId. Let's make it explicit.
  // The 'data.senderId' is the peer who sent the message (the shooter).
  // The 'data.bullet.shooterId' is who the sender claims shot the bullet (should be themselves).
  // Sticking to data.senderId as the shooter of the bullet for remote bullets.

  // Refined section in handleData:
  // if(data.shoot && data.bullet) spawnRemoteBullet(data.bullet, data.senderId);


  // — Inventory Toggle —
  document.getElementById('inventory').onclick=()=>{
    const d=document.getElementById('inventoryDetails');
    d.style.display = d.style.display==='block'?'none':'block';
  };

  // — Start / End UI & Loop —
  document.getElementById('startGame').onclick=()=>{
    document.getElementById('startOverlay').style.display='none';
    // send({}); // Initial send might not be needed if using greeting or relying on first update
  };
  const endOv=document.getElementById('endOverlay'), endMsg=document.getElementById('endMsg');
  function showEnd(msg){ 
      endMsg.textContent=msg; 
      endOv.style.display='flex'; 
      if (msg === 'You Died') {
          document.getElementById('rematch').style.display = 'none'; // Hide rematch if dead
          document.getElementById('respawnButton').style.display = 'inline-block'; // Show respawn
      } else {
          document.getElementById('rematch').style.display = 'inline-block'; // Show rematch for other end conditions
          document.getElementById('respawnButton').style.display = 'none';
      }
  }

  document.getElementById('rematch').onclick=()=>{
    myHealth = 5; myKills = 0; // Reset local player
    localPlayerState = 'alive';
    if(player) {
        Body.setStatic(player, false); // Matter.js
        player.isSensor = false; // Restore as non-sensor
    }

    document.getElementById('myHealth').value = myHealth;
    document.getElementById('myKills').textContent = '0';
    if(player) {
      Body.setPosition(player, { x: spawnPoints[localPlayerSpawnIndex].x, y: spawnPoints[localPlayerSpawnIndex].y }); 
      Body.setVelocity(player, { x:0, y:0 }); 
      Body.setAngularVelocity(player, 0); 
    }

    // For opponents, their health reset will be communicated via network messages.
    // Or, a specific "rematch" signal could be sent.
    Object.keys(opponents).forEach(opId => { 
      const op = opponents[opId];
      if (op && op.body) { 
        op.state = 'alive'; // Opponent is also alive on rematch
        Body.setStatic(op.body, false); // Matter.js
        op.body.isSensor = false; // Restore as non-sensor
        const opSpawnPoint = op.spawnPoint || { x: WORLD_WIDTH - size, y: WORLD_HEIGHT / 2 }; 
        Body.setPosition(op.body, { x: opSpawnPoint.x, y: opSpawnPoint.y }); 
        Body.setVelocity(op.body, { x:0, y:0 }); 
        Body.setAngularVelocity(op.body, 0); 
        const healthBar = document.getElementById(`health-${op.conn.peer}`);
        if (healthBar) healthBar.value = 5;
        op.health = 5;
        op.isDefeated = false; 
      }
    });
    // Send rematch signal along with current player's alive state
    send({ 
        rematchSignal: true, 
        playerState: { targetId: peer ? peer.id : 'local', state: 'alive' },
        pos: player ? [player.position.x, player.position.y] : [spawnPoints[localPlayerSpawnIndex].x, spawnPoints[localPlayerSpawnIndex].y],
        healthUpdate: {targetId: peer ? peer.id : 'local', newHealth: myHealth }
        // shooterId might not be needed in rematchSignal itself, but rather when bullets are created
    }); 

    bullets.forEach(b => World.remove(world, b)); // Reverted
    bullets.length=0;
    endOv.style.display='none';
    send({ health:myHealth });
  };

  document.getElementById('respawnButton').onclick = () => {
      if (localPlayerState !== 'dead') return; // Only allow respawn if dead

      localPlayerState = 'alive';
      myHealth = 5; // Reset health (use max health constant if available)
      document.getElementById('myHealth').value = myHealth;

      // Restore player body physics
      if (player) { // Ensure player body exists
        Body.setStatic(player, false); // Matter.js
        player.isSensor = false; // Restore as non-sensor
      }

      // Move player to a spawn point
      const spawnPoint = spawnPoints[localPlayerSpawnIndex]; // Or a random one
      if (player && spawnPoint) { // Ensure both exist
        Body.setPosition(player, { x: spawnPoint.x, y: spawnPoint.y });
        Body.setVelocity(player, { x:0, y:0 });
        Body.setAngularVelocity(player, 0);
      }
            
      // Update camera
      if (player) { // Ensure player exists for camera update
        cam.x = player.position.x;
        cam.y = player.position.y;
      }

      // Send respawn state to others
      if (peer && player) { // Ensure peer and player exist for sending data
        send({ 
            playerState: { targetId: peer.id, state: 'alive' },
            pos: [player.position.x, player.position.y], // Send current position
            healthUpdate: { targetId: peer.id, newHealth: myHealth } // Send current health
        });
      }
            
      endOv.style.display='none'; // Hide the overlay
      document.getElementById('rematch').style.display = 'inline-block'; // Restore rematch button visibility
  };

  function update(){
    Body.setVelocity(player,{ x:leftStick.x*6, y:leftStick.y*6 }); // Reverted
    
    // player.aimAngle update removed, assuming player.angle (physics body angle) will be used or aiming is visual only.
    // If aiming needs to rotate the physics body, Body.setAngle(player, newAngle) would be used here.
    // For now, sticking to original Matter.js behavior where player.angle is physics driven.

    cam.x=player.position.x; cam.y=player.position.y;
    Engine.update(engine,1000/60); // Reverted
    send({});
    render();
    requestAnimationFrame(update);
  }

  // const euler = new CANNON.Vec3(); // Removed as it's for Cannon.js quaternions
  function render(){
    applyCamera();
    // draw blocks
    blocks.forEach(b=>{
      ctx.save();
      ctx.translate(b.position.x, b.position.y);
      ctx.rotate(b.angle); // Reverted to Matter.js angle
      
      // Color logic based on _isInteractive or isStatic (original way)
      if (b._isInteractive) {
        ctx.fillStyle = '#888'; 
      } else if (b.isStatic) { // Matter.js uses isStatic
        ctx.fillStyle = '#555'; 
      } else { 
        ctx.fillStyle = '#AAA'; // Fallback
      }
      // Original renderSize logic might be needed if it varied for non-static blocks
      const renderSize = b.isStatic ? blockSize : (b.render && b.render.sprite && b.render.sprite.xScale ? blockSize * b.render.sprite.xScale : blockSize);
      ctx.fillRect(-renderSize/2, -renderSize/2, renderSize, renderSize);
      ctx.restore();
    });
    // draw players
    // Draw local player
    if (localPlayerState === 'alive') {
        ctx.save();
        ctx.translate(player.position.x, player.position.y);
        ctx.rotate(player.angle); // Reverted to Matter.js player.angle
        ctx.fillStyle = '#4af'; // Local player color
        ctx.fillRect(-size/2, -size/2, size, size);
        ctx.restore();
    }

    // Draw opponents
    Object.values(opponents).forEach(op => {
      // Check if opponent, its body, and its state exist, and if state is not 'dead'
      if (op && op.body && op.state !== 'dead') { 
        ctx.save();
        ctx.translate(op.body.position.x, op.body.position.y);
        ctx.rotate(op.body.angle); // Reverted to Matter.js op.body.angle
        ctx.fillStyle = '#fa4'; // Opponent color
        ctx.fillRect(-size/2, -size/2, size, size);
        ctx.restore();
      }
    });
    // draw bullets
    bullets.forEach(b=>{
      ctx.beginPath();
      ctx.arc(b.position.x, b.position.y, 5, 0, 2*Math.PI);
      ctx.fillStyle='#fff'; ctx.fill();
    });
    // draw blue world border
    ctx.lineWidth=4/scale;
    ctx.strokeStyle='blue';
    ctx.strokeRect(0,0,WORLD_WIDTH, WORLD_HEIGHT);
  }

  update();
  // prevent page scroll on touch
  document.body.addEventListener('touchmove',e=>e.preventDefault(),{ passive:false });
  </script>
</body>
</html>
